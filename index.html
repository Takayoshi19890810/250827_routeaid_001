<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>実車評価支援ツール</title>
<link rel="stylesheet" href="leaflet.css" />
<style>
  html,body{height:100%;margin:0}
  #map{position:fixed; inset:0; background:#f2f2f2; transform-origin:center center; z-index:0;}
  #panel{
    position:fixed; left:10px; top:calc(10px + env(safe-area-inset-top));
    z-index:2147483000; background:#fff; padding:10px 12px; border-radius:12px;
    box-shadow:0 6px 24px rgba(0,0,0,.18); font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    min-width:300px; max-width:min(94vw,560px)
  }
  #panel h1{font-size:18px;margin:6px 0 12px}
  #panel .row{display:flex; gap:8px; align-items:center; margin:8px 0}
  #panel .row .grow{flex:1 1 auto}
  #panel .group{border-top:1px dashed #e5e7eb; margin-top:10px; padding-top:10px}
  .col{display:flex; flex-direction:column; gap:6px}
  .row{display:flex; gap:8px; align-items:center}
  .row>label{white-space:nowrap}
  .small{font-size:11px;color:#555}
  .grow{flex:1 1 auto;min-width:140px}
  button{padding:10px 14px; min-height:40px; border-radius:12px; cursor:pointer; border:1px solid #ddd; background:#fff;}
  select, input[type=range]{height:40px;border-radius:10px;border:1px solid #ddd;padding:0 8px}
  #start{background:#16a34a;color:#fff;border-color:#16a34a}
  #stop{background:#ef4444;color:#fff;border-color:#ef4444}
  #recenter{background:#0ea5e9;color:#fff;border-color:#0ea5e9}
  #cp{background:#f59e0b;color:#fff;border-color:#f59e0b}
  #saveGpx{background:#6366f1;color:#fff;border-color:#6366f1}
  #fabStop{position:fixed; right:calc(12px + env(safe-area-inset-right)); bottom:calc(12px + env(safe-area-inset-bottom));
    z-index:2147483200; display:none; width:84px;height:84px;border-radius:50%; box-shadow:0 12px 36px rgba(0,0,0,.28);
    border:none; background:#ef4444;color:#fff;font-size:16px;font-weight:700;}
  #recBadge{position:fixed; right:12px; top:calc(12px + env(safe-area-inset-top));
    z-index:2147483200; display:none; align-items:center; gap:6px;
    background:rgba(239,68,68,.95); color:#fff; padding:6px 10px; border-radius:9999px; font-weight:700;}
  #recBadge i{display:inline-block; width:10px;height:10px; border-radius:50%; background:#fff; animation:blink 1s infinite}
  @keyframes blink{0%,60%{opacity:1} 61%,100%{opacity:.2}}

  #compass{position:fixed; right:calc(14px + env(safe-area-inset-right)); top:calc(78px + env(safe-area-inset-top)); width:52px;height:52px; z-index:2147483200; display:none;}
  #compass canvas{width:100%;height:100%}

  .toast{position:fixed; left:50%; bottom:calc(14px + env(safe-area-inset-bottom)); transform:translateX(-50%);
    z-index:2147483500; background:rgba(0,0,0,.86); color:#fff; padding:10px 14px; border-radius:9999px; font-size:14px;}

/* === Panel toggle === */
#togglePanel{
  position:fixed;
  left:12px;
  top:12px;
  z-index:2147483300;
  background:#111;
  color:#fff;
  border:1px solid #111;
  border-radius:9999px;
  padding:8px 12px;
  font-weight:700;
  box-shadow:0 8px 24px rgba(0,0,0,.25);
}
#panel.is-hidden{ display:none; }
</style>
</head>
<body>
<div id="map"></div>

<div id="panel">
  <h1>実車評価支援ツール</h1>

  <!-- 複数ファイル入力 + 切替セレクタ -->
  <div class="group col">
    <div class="row">
      <label>評価データ</label>
      <input id="file" type="file" accept=".kml,.kmz,.gpx,application/vnd.google-earth.kmz" class="grow" multiple />
      <select id="datasetSelect" class="grow">
        <option value="">（選択中のデータ）</option>
      </select>
    </div>
    <div class="row small">
      <span>※ KML/KMZ/GPX からピンを読み込み。ルート用のピンは読み上げしません。</span>
    </div>
  </div>

  <div class="group col">
    <div class="row">
      <button id="start">追跡開始</button>
      <button id="stop" disabled>追跡終了</button>
      <button id="recenter">自車へ</button>
      <button id="cp" title="チェックポイント">CP</button>
    </div>
    <div class="row small">
      <label><input id="northUp" type="radio" name="dir" checked /> 北を上</label>
      <label><input id="headingUp" type="radio" name="dir" /> 進行方向を上</label>
      <label><input id="followMe" type="checkbox" checked /> 常に自車を中心</label>
    </div>
    <div class="row">
      <label>通知半径</label>
      <input id="radius" type="range" min="50" max="800" step="10" value="150" class="grow" />
      <span id="radiusVal">150m</span>
    </div>
    <div class="row">
      <label>再通知距離</label>
      <input id="renotify" type="range" min="50" max="1000" step="50" value="300" class="grow" />
      <span id="renotifyVal">300m</span>
    </div>
  </div>

  <div class="group col">
    <div class="row">
      <button id="saveGpx" disabled>GPX保存</button>
    </div>
    <div class="row small">
      <span>※ 追跡終了時にも保存確認が出ます。</span>
    </div>
  </div>

  <div class="group col">
    <div class="row small">
      <span>音声：端末の設定を使用（iOSは設定＞アクセシビリティ＞読み上げコンテンツ）</span>
    </div>
    <div class="row small">
      <span>GPS弱い時は通知。開始直後、半径内のポイントも読み上げ。</span>
    </div>
  </div>
</div>
<button id="togglePanel" aria-label="メニュー表示切替">メニュー</button>

<button id="fabStop" aria-label="緊急停止">停止</button>
<div id="recBadge"><i></i><span>REC</span></div>
<div id="compass"><canvas width="100" height="100"></canvas></div>

<script src="leaflet.js"></script>
<script src="jszip.min.js"></script>
<script src="togeojson.umd.js"></script>
<script>
'use strict';

// ===== 地図セットアップ =====
const map = L.map('map', { zoomControl:false, preferCanvas:true }).setView([35.681236,139.767125], 15);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors', maxZoom: 19
}).addTo(map);

// UI要素
const fileInput = document.getElementById('file');
const datasetSelect = document.getElementById('datasetSelect');
const start = document.getElementById('start');
const stop = document.getElementById('stop');
const fabStop = document.getElementById('fabStop');
const recBadge = document.getElementById('recBadge');
const northUp = document.getElementById('northUp');
const headingUp = document.getElementById('headingUp');
const followMe = document.getElementById('followMe');
const radius = document.getElementById('radius');
const radiusVal = document.getElementById('radiusVal');
const renotify = document.getElementById('renotify');
const renotifyVal = document.getElementById('renotifyVal');
const saveGpx = document.getElementById('saveGpx');
const recCanvas = document.querySelector('#compass canvas');
const $compass = document.getElementById('compass');

const panel = document.getElementById('panel');
const togglePanelBtn = document.getElementById('togglePanel');

// レイヤ（自車・軌跡・半径）
const trackLine = L.polyline([], { color:'#ef4444', weight:4 }).addTo(map);
const meMarker = L.circleMarker([0,0], { radius:7, color:'#ef4444', fillColor:'#ef4444', fillOpacity:1 }).addTo(map);
const radiusCircle = L.circle([0,0], { radius:150, color:'#0ea5e9', weight:1, fillColor:'#0ea5e9', fillOpacity:.08 }).addTo(map);

// データセット（複数ファイルを個別にON/OFFできるように管理）
let datasets = []; // [{name, group, pois, routePins}]
let currentDatasetIndex = -1;
let pois = [];      // 現在選択中データの読み上げポイント
let routePins = []; // 現在選択中データのルート用ピン

function createDataset(name){
  return { name, group: L.layerGroup().addTo(map), pois:[], routePins:[] };
}
function addPoi(lat,lng,prop, ds){
  const m=L.circleMarker([lat,lng], {radius:8, color:'#10b981', fillColor:'#10b981', fillOpacity:1});
  m.bindTooltip(prop?.name||prop?.description||'');
  ds.group.addLayer(m);
  ds.pois.push({lat,lng, note:prop?.name||prop?.description||''});
}
function addRoutePin(lat,lng,prop, ds){
  const m=L.circleMarker([lat,lng], {radius:6, color:'#64748b', fillColor:'#e2e8f0', fillOpacity:1});
  m.bindTooltip(prop?.name||'');
  ds.group.addLayer(m);
  ds.routePins.push({lat,lng});
}
function updateDatasetSelectOptions(){
  if(!datasets.length){
    datasetSelect.innerHTML = '<option value="">（選択中のデータ）</option>';
    currentDatasetIndex = -1; pois=[]; routePins=[];
    return;
  }
  datasetSelect.innerHTML = datasets.map((ds,i)=>`<option value="${i}" ${i===datasets.length-1?'selected':''}>${ds.name}（${ds.pois.length}点）</option>`).join('');
  applyDatasetSelection(String(datasets.length-1));
}
function fitToDataset(ds){
  try{
    const b = ds.group.getBounds();
    if(b && b.isValid && b.isValid()){
      map.fitBounds(b, {padding:[40,40]});
    }
  }catch(e){ console.warn(e); }
}
  datasetSelect.innerHTML = datasets.map((ds,i)=>`<option value="${i}" ${i===datasets.length-1?'selected':''}>${ds.name}（${ds.pois.length}点）</option>`).join('');
  applyDatasetSelection(String(datasets.length-1));
}
function applyDatasetSelection(index){
  const idx = parseInt(index,10);
  datasets.forEach((ds,i)=>{ if(i===idx){ map.addLayer(ds.group); } else { map.removeLayer(ds.group); }});
  if(!isNaN(idx) && datasets[idx]){
    pois = datasets[idx].pois; routePins = datasets[idx].routePins; currentDatasetIndex = idx;
  }
}

datasetSelect.addEventListener('change', e=>{ applyDatasetSelection(e.target.value); });

// ファイル読み込み
async function handleFiles(files){
  for(const f of files){
    const buf = await f.arrayBuffer();
    const ds = createDataset(f.name);
    let kmlText = '';

    if(/\.kmz$/i.test(f.name)){
      // KMZ: ZIPからKML抽出（UMDのJSZipをグローバル利用）
      try{
        const zip = await JSZip.loadAsync(buf);
        const kmlEntry = Object.keys(zip.files).find(k=>/\.kml$/i.test(k));
        if(kmlEntry){
          kmlText = await zip.files[kmlEntry].async('string');
        } else {
          throw new Error('KMZ内にKMLが見つかりません');
        }
      }catch(e){ console.error(e); toast('KMZの展開に失敗'); }
    }else{
      const text = new TextDecoder('utf-8').decode(buf);
      if(/<kml/i.test(text)) kmlText = text;
      else if(/<gpx/i.test(text)){
        // GPX: wpt -> 読み上げ対象, trk -> ルート
        try{
          const dom = new DOMParser().parseFromString(text, 'application/xml');
          dom.querySelectorAll('wpt').forEach(w=> addPoi(parseFloat(w.getAttribute('lat')), parseFloat(w.getAttribute('lon')), {name:w.querySelector('name')?.textContent||''}, ds));
          dom.querySelectorAll('trkseg trkpt').forEach(tp=> addRoutePin(parseFloat(tp.getAttribute('lat')), parseFloat(tp.getAttribute('lon')), {}, ds));
          toast(`${f.name} を読み込み（ポイント${ds.pois.length}）`);
datasets.push(ds); updateDatasetSelectOptions(); fitToDataset(ds);
        }catch(e){ console.error(e); toast('GPX読込失敗'); }
        continue;
      }else{
        // （GeoJSONは不要の方針だが、念のためPointだけ対応したい場合はここに実装）
        // 今回はスキップ
        continue;
      }
    }

    if(kmlText){
      try{
        const dom = new DOMParser().parseFromString(kmlText, 'text/xml');
        const kml = toGeoJSON.kml(dom);
        // スタイル名に route が含まれるものはルート扱い、それ以外は読み上げ対象
        for(const feat of (kml.features||[])){
          if(feat.geometry?.type==='Point'){
            const p=feat.properties||{}; const name=p.name||p.description||''; const style=(p.styleUrl||'')+(p.icon||'');
            const [lng,lat] = feat.geometry.coordinates;
            if(/route|line|path/i.test(style)) addRoutePin(lat,lng,{name}, ds);
            else addPoi(lat,lng,{name}, ds);
          }
        }
        toast(`${f.name} を読み込み（ポイント${ds.pois.length}）`); datasets.push(ds); updateDatasetSelectOptions(); fitToDataset(ds);
      }catch(e){ console.error(e); toast('KML読込失敗'); }
    }
  }
}

fileInput.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files||[]);
  if(!files.length){ datasetSelect.innerHTML = '<option value="">（選択中のデータ）</option>'; return; }
  // 先に"読み込み中"でプレースホルダを表示（即時フィードバック）
  const existing = datasets.map((ds,i)=>`<option value="${i}" ${i===currentDatasetIndex?'selected':''}>${ds.name}（${ds.pois.length}点）</option>`).join('');
  const loading = files.map(f=>`<option disabled>${f.name} 読み込み中...</option>`).join('');
  datasetSelect.innerHTML = existing + loading;
  await handleFiles(files);
});

// 半径UI
radius.addEventListener('input', ()=>{ radiusVal.textContent = `${radius.value}m`; radiusCircle.setRadius(+radius.value); });
renotify.addEventListener('input', ()=>{ renotifyVal.textContent = `${renotify.value}m`; });

// 位置追跡
let tracking=false, watchId=null, heading=0, lastFixTime=0;
let startupSweepTimer=null, gpsWeakTimer=null;
let lastReadMap = new Map(); // id -> lastReadDistance

function onPos(p){
  const {latitude:lat, longitude:lng, heading:hdg} = p.coords;
  lastFixTime = Date.now();
  meMarker.setLatLng([lat,lng]);
  radiusCircle.setLatLng([lat,lng]);
  if(followMe.checked){ map.setView([lat,lng], map.getZoom(), {animate:false}); }
  if(headingUp.checked){ rotateMap(-(hdg||0)); $compass.style.display='block'; drawCompass(hdg||0); } else { rotateMap(0); $compass.style.display='none'; }

  if(tracking){
    trackLine.addLatLng([lat,lng]);
    checkAnnounce([lat,lng]);
  }
}
function onPosErr(err){ console.warn(err); }

function startTracking(){
  if(tracking) return;
  tracking=true; lastReadMap.clear(); trackLine.setLatLngs([]);
  start.disabled=true; stop.disabled=false; fabStop.style.display='block'; recBadge.style.display='flex';
  enqueueSpeech(['追跡を開始します']);

  // 開始直後、半径内のポイントを読み上げ
  sweepAnnounce();

  watchId = navigator.geolocation.watchPosition(onPos, onPosErr, { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
  startupSweepTimer = setInterval(sweepAnnounce, 4000);
  gpsWeakTimer = setInterval(()=>{
    if(Date.now()-lastFixTime>7000){ toast('GPS信号が弱いです'); enqueueSpeech(['GPS信号が弱いです']); }
  }, 3000);
}

function stopTracking(){
  if(!tracking) return;
  tracking=false;
  navigator.geolocation.clearWatch?.(watchId); watchId=null;
  clearInterval(startupSweepTimer); clearInterval(gpsWeakTimer);
  start.disabled=false; stop.disabled=true; fabStop.style.display='none'; document.getElementById('recBadge').style.display='none';
  rotateMap(0); $compass.style.display='none';
  unlockTTS(); enqueueSpeech(['評価を終了します']);

  // 追跡終了後のGPX保存フロー（確認 → ファイル名入力 → 保存）
  try{
    const latlngs = trackLine.getLatLngs();
    if(latlngs && latlngs.length){
      const doSave = confirm('GPXを保存しますか？');
      if(doSave){
        const defaultName = `track_${formatTs()}.gpx`;
        const name = prompt('保存するファイル名を入力してください（.gpx）', defaultName) || defaultName;
        const gpx = buildGPX(latlngs, cps || []);
        downloadText(gpx, name.endsWith('.gpx') ? name : `${name}.gpx`, 'application/gpx+xml');
        toast('GPXを保存しました');
      }
    }else{
      toast('保存できる軌跡がありません');
    }
  }catch(e){
    console.error(e);
    toast('保存に失敗しました');
  }

  cpBtn.disabled=true;
}
  
start.addEventListener('click', startTracking);
stop.addEventListener('click', stopTracking);
fabStop.addEventListener('click', stopTracking);

// 明示保存ボタン（残す）
saveGpx.addEventListener('click', ()=>{
  const latlngs = trackLine.getLatLngs();
  if(!latlngs || !latlngs.length){ toast('保存できる軌跡がありません'); return; }
  const name = `track_${formatTs()}.gpx`;
  const gpx = buildGPX(latlngs, cps||[]);
  downloadText(gpx, name, 'application/gpx+xml');
  toast('GPXを保存しました');
});

// チェックポイント
const cpBtn = document.getElementById('cp');
cpBtn.addEventListener('click', ()=>{
  navigator.geolocation.getCurrentPosition(p=>{
    const note = confirm('メモを入力しますか？') ? (prompt('メモを入力','')||'') : '';
    const {latitude:lat, longitude:lng} = p.coords;
    cps.push({lat,lng,note,t:Date.now()});
    L.circleMarker([lat,lng], {radius:8, color:'#f59e0b', fillColor:'#f59e0b', fillOpacity:1}).addTo(map).bindTooltip(note||'CP');
    toast('CPを追加');
  });
});

// 進行方向コンパス
function drawCompass(deg){
  const ctx=recCanvas.getContext('2d');
  const w=recCanvas.width, h=recCanvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save();
  ctx.translate(w/2,h/2);
  ctx.rotate(deg*Math.PI/180);
  ctx.beginPath(); ctx.moveTo(0,-40); ctx.lineTo(6,0); ctx.lineTo(-6,0); ctx.closePath();
  ctx.fillStyle='#ef4444'; ctx.fill();
  ctx.restore();
}

function dist(a,b){
  const R=6371000;
  const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); const dLng=toRad(b[1]-a[1]);
  const la1=toRad(a[0]); const la2=toRad(b[0]);
  const s = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
}

function checkAnnounce(my){
  const r = +radius.value;
  for(let i=0;i<pois.length;i++){
    const p=pois[i];
    const d = dist(my,[p.lat,p.lng]);
    const last = lastReadMap.get(i)||Infinity;
    if(d<=r && d>=50 && (isNaN(last) || last>=+renotify.value)){
      enqueueSpeech([p.note||'評価ポイント']);
      lastReadMap.set(i,0);
    }else if(d>r){
      lastReadMap.set(i,Math.min(20000, d));
    }
  }
}

function sweepAnnounce(){
  navigator.geolocation.getCurrentPosition(p=>{
    const my=[p.coords.latitude,p.coords.longitude];
    const r=+radius.value;
    let any=false;
    pois.forEach((poi,idx)=>{
      const d=dist(my,[poi.lat,poi.lng]);
      if(d<=r){ enqueueSpeech([poi.note||'評価ポイント']); lastReadMap.set(idx,0); any=true; }
    });
    if(any) toast('開始直後の半径内ポイントを読み上げ');
  });
}

// 再センター
const recenter = document.getElementById('recenter');
recenter.addEventListener('click', ()=>{
  navigator.geolocation.getCurrentPosition(p=>{
    map.setView([p.coords.latitude,p.coords.longitude], Math.max(16, map.getZoom()))
  });
});

// Panel toggle
document.getElementById('togglePanel').addEventListener('click', ()=>{
  document.getElementById('panel').classList.toggle('is-hidden');
});

/* === TTS iOS/Safari 安定化（追記） === */
let audioCtx; let ttsPrimed=false;
function initAudioUnlock(){ try{ if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); } if(audioCtx.state==='suspended') audioCtx.resume(); }catch{} }
function waitForVoices(){ return new Promise(resolve=>{ const v=window.speechSynthesis?.getVoices?.(); if(v&&v.length){ return resolve(v);} const t=setTimeout(()=>resolve(window.speechSynthesis?.getVoices?.()||[]),1000); try{ window.speechSynthesis.onvoiceschanged=()=>{ clearTimeout(t); resolve(window.speechSynthesis.getVoices()); }; }catch{} }); }
async function ensureTTSReady(){ if(!('speechSynthesis' in window)) return false; initAudioUnlock(); try{ window.speechSynthesis.resume(); }catch{} await waitForVoices(); if(!ttsPrimed){ try{ const u=new SpeechSynthesisUtterance(' '); u.volume=0; window.speechSynthesis.speak(u);}catch{} ttsPrimed=true;} return true; }
function enqueueSpeech(texts){ (async()=>{ if(!('speechSynthesis' in window)) { toast('この端末は読み上げ非対応'); return; } const ok=await ensureTTSReady(); if(!ok) return; try{ for(const tx of texts){ const u=new SpeechSynthesisUtterance(String(tx)); window.speechSynthesis.speak(u);} }catch(e){ console.error(e);} })(); }
['touchstart','click'].forEach(evt=>{ window.addEventListener(evt, ()=>{ initAudioUnlock(); try{ window.speechSynthesis.resume(); }catch{} }, {once:true, capture:true}); });
// テストボタンがあれば動作確認
(document.getElementById('ttsTest')||{}).onclick = ()=> enqueueSpeech(['音声テストです']);
</script>
</body>
</html>
