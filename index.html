<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>実車評価支援ツール</title>
<link rel="stylesheet" href="leaflet.css" />
<style>
  html,body{height:100%;margin:0}
  /* 地図は背面に固定（UIと分離） */
  #map{
    position:fixed; inset:0; background:#f2f2f2;
    transform-origin:center center;             /* 回転基点 */
    z-index:0;                                   /* 背面 */
  }
  /* パネル（見やすい旧型UI） */
  #panel{
    position:fixed; left:10px; top:calc(10px + env(safe-area-inset-top));
    z-index:2147483000;
    background:#fff; padding:10px 12px; border-radius:12px;
    box-shadow:0 6px 24px rgba(0,0,0,.18);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    min-width:300px; max-width:min(94vw,520px)
  }
  #panel h1{margin:0 0 8px;font-size:15px;font-weight:700}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
  .row>label{white-space:nowrap}
  .small{font-size:11px;color:#555}
  button{
    padding:10px 14px; min-height:40px; border-radius:12px;
    cursor:pointer; border:1px solid #ddd; background:#fff;
    touch-action:manipulation; pointer-events:auto;
  }
  #start{background:#16a34a;color:#fff;border-color:#16a34a}
  #stop{background:#ef4444;color:#fff;border-color:#ef4444}
  #recenter{background:#0ea5e9;color:#fff;border-color:#0ea5e9}
  #cp{background:#f59e0b;color:#fff;border-color:#f59e0b}
  #saveGpx,#saveGeo{background:#6366f1;color:#fff;border-color:#6366f1}

  /* 停止の大ボタン（押しやすい） */
  #fabStop{
    position:fixed;
    right:calc(14px + env(safe-area-inset-right));
    bottom:calc(14px + env(safe-area-inset-bottom));
    z-index:2147483647;
    width:68px;height:68px;border-radius:50%;border:none;
    box-shadow:0 10px 28px rgba(0,0,0,.25);
    background:#ef4444;color:#fff;font-size:16px;font-weight:700;
    display:none; touch-action:manipulation; pointer-events:auto;
  }

  #recBadge{
    position:fixed; right:12px; top:calc(12px + env(safe-area-inset-top));
    z-index:2147483200; display:none; align-items:center; gap:6px;
    background:rgba(239,68,68,.95); color:#fff; padding:6px 10px; border-radius:9999px;
    box-shadow:0 6px 24px rgba(0,0,0,.18); font-size:12px
  }
  .dot{width:10px;height:10px;border-radius:50%;background:#fff;animation:blink 1s infinite}
  @keyframes blink{0%,60%{opacity:1}61%,100%{opacity:.25}}

  #toast{
    position:fixed; left:50%; bottom:calc(78px + env(safe-area-inset-bottom)); transform:translateX(-50%);
    z-index:2147483100; display:none; max-width:min(92vw,520px);
    background:rgba(0,0,0,.85); color:#fff; padding:10px 14px; border-radius:12px;
    box-shadow:0 6px 24px rgba(0,0,0,.35); font-size:14px
  }
  #compass{
    position:fixed; right:calc(14px + env(safe-area-inset-right)); top:calc(74px + env(safe-area-inset-top));
    z-index:2147483001; width:44px;height:44px;border-radius:50%;background:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,.2); display:none; place-items:center; font-size:12px;color:#111;
  }
  #compassArrow{width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:14px solid #ef4444;transform-origin:50% 90%}

  /* ファイル名が長いとき折返し */
  #fname{max-width:180px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
</style>
</head>
<body>
<div id="map"></div>

<div id="recBadge"><span class="dot"></span>追跡中</div>
<div id="toast"></div>
<div id="compass"><div id="compassArrow"></div><div style="font-size:10px;margin-top:2px">N</div></div>

<!-- 押せる停止（inlineも冗長化） -->
<button id="fabStop" aria-label="追跡終了" onclick="window.__stopTracking && window.__stopTracking()">停止</button>

<div id="panel">
  <h1>実車評価支援ツール</h1>

  <div class="row">
    <input id="file" type="file" accept=".kml,.kmz,application/vnd.google-earth.kml+xml,application/vnd.google-earth.kmz" />
    <button id="clear">クリア</button>
    <span id="fname" class="small">（未選択）</span>
  </div>

  <div class="row">
    <label>通知半径(m):</label>
    <input id="th" type="number" value="100" min="20" max="5000" step="10" style="width:90px" />
    <button id="recenter">現在地へ</button>
  </div>

  <div class="row">
    <button id="start">追跡開始</button>
    <button id="stop" disabled onclick="window.__stopTracking && window.__stopTracking()" aria-label="追跡終了">追跡終了</button>
    <button id="cp">チェックポイント</button>
    <label><input type="checkbox" id="withMemo" />メモ入力</label>
  </div>

  <div class="row">
    <label><input type="checkbox" id="keepCentered" checked />自車を常に中心</label>
    <label style="margin-left:10px">向き:</label>
    <label><input type="radio" name="orient" value="north" checked />北を上</label>
    <label><input type="radio" name="orient" value="course" />進行方向を上</label>
  </div>

  <div class="row">
    <button id="tts">音声テスト</button>
    <button id="wake">画面オフ防止: OFF</button>
  </div>

  <div class="row">
    <button id="saveGpx" disabled>GPX保存</button>
    <button id="saveGeo" disabled>GeoJSON保存</button>
    <span id="stat" class="small"></span>
  </div>
</div>

<script src="leaflet.js"></script>
<script src="jszip.min.js"></script>
<script src="togeojson.umd.js"></script>
<script>
(function(){
  /* ===== ピン定義：青=評価ポイント / 灰=ルート汎用 / 橙=手動CP ===== */
  function svg(color){return encodeURIComponent(
    `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36">
      <path d="M12 36s10-12.2 10-20A10 10 0 1 0 2 16c0 7.8 10 20 10 20z" fill="${color}"/>
      <circle cx="12" cy="12" r="4.5" fill="#fff"/></svg>`)}
  const Blue   = L.Icon.extend({options:{iconUrl:`data:image/svg+xml;charset=UTF-8,${svg('#2A7FFF')}`, iconSize:[24,36],iconAnchor:[12,34],popupAnchor:[0,-30]}});
  const Orange = L.Icon.extend({options:{iconUrl:`data:image/svg+xml;charset=UTF-8,${svg('#F59E0B')}`, iconSize:[24,36],iconAnchor:[12,34],popupAnchor:[0,-30]}});
  const Gray   = L.Icon.extend({options:{iconUrl:`data:image/svg+xml;charset=UTF-8,${svg('#9CA3AF')}`, iconSize:[24,36],iconAnchor:[12,34],popupAnchor:[0,-30]}});
  const iconBlue=new Blue(), iconOrange=new Orange(), iconGray=new Gray();

  /* ====== 地図セットアップ ====== */
  const map = L.map('map', {zoomControl:true}).setView([35.681,139.767], 13);
  const tile = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom:19, attribution:'&copy; OpenStreetMap'}).addTo(map);

  const routeLayer = L.layerGroup().addTo(map);      // ルート（線）
  const pointLayer = L.layerGroup().addTo(map);      // 評価ポイント（読み上げ対象）
  const routeMarkerLayer = L.layerGroup().addTo(map);// ルート用のマーカー（表示のみ／読み上げなし）
  const checkpointLayer = L.layerGroup().addTo(map); // 手動チェックポイント

  // 自車
  const me = L.circleMarker([35.681,139.767],{radius:7,weight:2,color:'#0ea5e9',fillColor:'#fff',fillOpacity:1}).addTo(map);
  const trackLine = L.polyline([], {color:'#16a34a', weight:4, opacity:0.9}).addTo(map);

  // UI要素
  const $recBadge=document.getElementById('recBadge');
  const $toast=document.getElementById('toast');
  const $compass=document.getElementById('compass');
  const $compassArrow=document.getElementById('compassArrow');
  const start=document.getElementById('start');
  const stop=document.getElementById('stop');
  const fabStop=document.getElementById('fabStop');
  const stat=document.getElementById('stat');
  const keepCentered=document.getElementById('keepCentered');
  const th=document.getElementById('th');
  const file=document.getElementById('file');
  const fname=document.getElementById('fname');

  /* ===== 画面オフ防止 ===== */
  let wakeLock=null; const wake=document.getElementById('wake');
  async function toggleWake(){
    try{
      if(!wakeLock){ wakeLock=await navigator.wakeLock.request('screen'); wake.textContent='画面オフ防止: ON'; }
      else { await wakeLock.release(); wakeLock=null; wake.textContent='画面オフ防止: OFF'; }
    }catch(e){ toast('画面オフ防止を取得できません'); }
  }
  wake.addEventListener('click',toggleWake);

  /* ===== 方位・回転 ===== */
  let currentBearing=0, orientationMode='north';
  document.querySelectorAll('input[name=orient]').forEach(r=>{
    r.addEventListener('change',()=>{
      orientationMode=r.value;
      if(orientationMode==='north'){ rotateMap(0); $compass.style.display='none'; }
      else { $compass.style.display='grid'; }
    });
  });
  function bearingBetween(a,b){
    const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
    const lat1=toRad(a.lat), lon1=toRad(a.lng), lat2=toRad(b.lat), lon2=toRad(b.lng);
    const y=Math.sin(lon2-lon1)*Math.cos(lat2);
    const x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*Math.cos(lat2)*Math.cos(lon2-lon1);
    return (toDeg(Math.atan2(y,x))+360)%360;
  }
  function rotateMap(bearingDeg){
    const pane=map.getPanes().mapPane;
    pane.style.transform=`rotate(${-bearingDeg}deg)`;  // 地図だけ回す
    $compassArrow.style.transform=`rotate(${bearingDeg}deg)`; // 矢印は進行方向
  }
  function centerOnVisible(here){
    const panel = document.getElementById('panel').getBoundingClientRect();
    const fabEl = document.getElementById('fabStop');
    const fab   = fabEl.style.display==='none' ? null : fabEl.getBoundingClientRect();
    const offsetY = Math.round(panel.height/2 + 16);                 // 上のパネルに隠れない
    const offsetX = fab ? Math.round(fab.width/2 + 16) * -1 : 0;     // 右下FABに被らないよう左へ
    map.setView(here, map.getZoom(), {animate:false});
    map.panBy([offsetX, -offsetY], {animate:false});
  }

  /* ===== TTS ===== */
  let ttsQueue=[], speaking=false; let jpVoice=null; let ttsUnlocked=false;
  function unlockTTS(){
    if(ttsUnlocked) return; ttsUnlocked=true;
    speechSynthesis.cancel();
    const voices=speechSynthesis.getVoices();
    jpVoice = voices.find(v=>/ja-JP|japan/i.test(v.lang)) || voices[0] || null;
  }
  speechSynthesis.addEventListener('voiceschanged', unlockTTS);
  function enqueueSpeech(lines){
    for(const s of lines){ const u=new SpeechSynthesisUtterance(String(s)); if(jpVoice) u.voice=jpVoice; u.rate=1.0; u.pitch=1.0; ttsQueue.push(u); }
    if(!speaking) speakNext();
  }
  function speakNext(){
    if(!ttsQueue.length){ speaking=false; return; }
    speaking=true; const u=ttsQueue.shift(); u.onend=()=>{speaking=false; speakNext();}; speechSynthesis.speak(u);
  }
  document.getElementById('tts').addEventListener('click',()=>{ unlockTTS(); enqueueSpeech(['音声テストです']); });

  /* ===== ファイル読込（KML/KMZ） ===== */
  let geoPoints=[], routeLines=[]; // 読み上げ対象は geoPoints（Pointのみ）
  file.addEventListener('change', async (e)=>{
    clearLayers();
    const f=e.target.files?.[0]; if(!f) return;
    fname.textContent=f.name;
    const arr=await f.arrayBuffer();
    let kmlText='';
    if(/\.kmz$/i.test(f.name)){
      const zip=await JSZip.loadAsync(arr);
      // 最初に見つかったKMLを使う
      const kmlEntry = Object.values(zip.files).find(z=>/\.kml$/i.test(z.name));
      if(!kmlEntry){ toast('KMZ内にKMLが見つかりません'); return; }
      kmlText = await kmlEntry.async('text');
    }else{
      kmlText = new TextDecoder().decode(arr);
    }
    const xml = new DOMParser().parseFromString(kmlText,'text/xml');
    const fc  = toGeoJSON.kml(xml); // FeatureCollection

    // 分類：評価ポイント（Point）とルート（LineString / MultiLineString）
    geoPoints=[]; routeLines=[];
    for(const feat of fc.features){
      const name = feat.properties?.name || '';
      const desc = feat.properties?.description || '';
      if(feat.geometry?.type==='Point'){
        // ルート用ピンをできるだけ除外：名前やフォルダに route/ルート っぽい語がある場合は読み上げ対象にしない
        const lower = `${name}\n${desc}`.toLowerCase();
        const looksRoute = /route|ルート|経路|path/.test(lower);
        const latlng=[feat.geometry.coordinates[1], feat.geometry.coordinates[0]];
        const m=L.marker(latlng,{icon: looksRoute? new iconGray.options.constructor(): iconBlue});
        m.bindPopup(`<b>${escapeHTML(name||'無題')}</b><div>${escapeHTML(desc)}</div>`);
        if(looksRoute){ routeMarkerLayer.addLayer(m); }
        else { pointLayer.addLayer(m); geoPoints.push({latlng,name,desc,marker:m}); }
      }
      if(feat.geometry?.type==='LineString' || feat.geometry?.type==='MultiLineString'){
        const coords = feat.geometry.type==='LineString' ? [feat.geometry.coordinates] : feat.geometry.coordinates;
        for(const line of coords){
          const latlngs = line.map(([lng,lat])=>[lat,lng]);
          L.polyline(latlngs,{color:'#9CA3AF',weight:4,opacity:.8}).addTo(routeLayer);
          routeLines.push(latlngs);
        }
      }
    }
    // 表示範囲調整
    const b = L.featureGroup([routeLayer, pointLayer, routeMarkerLayer]).getBounds();
    if(b.isValid()) map.fitBounds(b.pad(0.2));
    toast(`読み込み完了：ポイント${geoPoints.length}件`);
  });

  document.getElementById('clear').addEventListener('click',()=>{ file.value=''; fname.textContent='（未選択）'; clearLayers(); });
  function clearLayers(){
    routeLayer.clearLayers(); pointLayer.clearLayers(); routeMarkerLayer.clearLayers(); checkpointLayer.clearLayers();
    geoPoints=[]; routeLines=[]; stat.textContent='';
  }

  /* ===== 近接判定＆読み上げ ===== */
  const notified = new Map(); // key: index to geoPoints -> {firstDist, lastSpokeAtDist}
  function collectNearTexts(here){
    const R = Number(th.value||100);
    const res=[];
    geoPoints.forEach((p,idx)=>{
      const d = here.distanceTo(p.marker.getLatLng()); // meters
      if(d<=R){
        const n = notified.get(idx) || {firstDist: d, lastSpokeAtDist: Infinity};
        if(!notified.has(idx)){
          notified.set(idx,{firstDist:d, lastSpokeAtDist:d});
          res.push(`${p.name||'ポイント'}。${p.desc? p.desc.replace(/<[^>]*>/g,'') : ''}`);
        }else{
          // 300m移動ごとに再通知
          if((Math.abs(n.firstDist - d) >= 300) || (distanceTravelledSinceSpeak >= 300)){
            n.lastSpokeAtDist=d; notified.set(idx,n);
            res.push(`${p.name||'ポイント'}。再通知です。`);
          }
        }
      }
    });
    return res;
  }
  function checkNearAndSpeak(here){
    const texts = collectNearTexts(here);
    if(texts.length) { enqueueSpeech(texts); distanceTravelledSinceSpeak = 0; }
  }

  /* ===== 追跡 ===== */
  let tracking=false, watchId=null; let lastLatLng=null, prevLatLng=null; let startupSweepTimer=null;
  let distanceTravelled=0; let distanceTravelledSinceSpeak=0;
  let lastFixTime=0; let weakGpsWarned=false;

  function toast(msg, ms=2000){ $toast.textContent=msg; $toast.style.display='block'; setTimeout(()=>{$toast.style.display='none'}, ms); }

  function onPosition(pos){
    const here = L.latLng(pos.coords.latitude, pos.coords.longitude);
    lastFixTime = Date.now();
    weakGpsWarned=false; // リセット

    if(lastLatLng){
      const moved = here.distanceTo(L.latLng(lastLatLng));
      distanceTravelled += moved; distanceTravelledSinceSpeak += moved;
    }
    prevLatLng = lastLatLng? L.latLng(lastLatLng): null;
    lastLatLng=[here.lat, here.lng];

    me.setLatLng(here); trackLine.addLatLng(here);

    // 方位推定
    let bearing=(typeof pos.coords.heading==='number'&&!isNaN(pos.coords.heading))
      ? pos.coords.heading : (prevLatLng? bearingBetween(prevLatLng,here):currentBearing);
    currentBearing=bearing;
    if(orientationMode==='course'){ rotateMap(bearing); $compass.style.display='grid'; }
    else { rotateMap(0); $compass.style.display='none'; }

    if(keepCentered.checked) centerOnVisible(here);
    checkNearAndSpeak(here);

    stat.textContent = `速度:${(pos.coords.speed||0).toFixed(1)}m/s 距離:${distanceTravelled.toFixed(0)}m 精度:${pos.coords.accuracy??'-'}m`;
  }

  function onPositionError(err){ stat.textContent=`位置エラー: ${err.message}`; }

  function startTracking(){
    if(tracking) return; unlockTTS();
    tracking=true; start.disabled=true; stop.disabled=false; fabStop.style.display='block'; $recBadge.style.display='flex';
    trackLine.setLatLngs([]); checkpointLayer.clearLayers();
    distanceTravelled=0; distanceTravelledSinceSpeak=0; weakGpsWarned=false; lastFixTime=Date.now();
    enqueueSpeech(['評価を開始します']);
    if(lastLatLng){ const t=collectNearTexts(L.latLng(lastLatLng)); if(t.length) enqueueSpeech(t); }

    if(navigator.geolocation){
      navigator.geolocation.getCurrentPosition(pos=>{
        const ll=[pos.coords.latitude,pos.coords.longitude];
        prevLatLng=lastLatLng?L.latLng(lastLatLng):null; lastLatLng=ll;
        me.setLatLng(ll);
        if(keepCentered.checked) centerOnVisible(L.latLng(ll)); else map.setView(ll,16);
        checkNearAndSpeak(L.latLng(ll));
      },()=>{}, {enableHighAccuracy:true,timeout:8000});
    }

    let sweep=0; clearInterval(startupSweepTimer);
    startupSweepTimer=setInterval(()=>{ if(!tracking){clearInterval(startupSweepTimer);return;}
      if(lastLatLng) checkNearAndSpeak(L.latLng(lastLatLng));
      if(++sweep>=10) clearInterval(startupSweepTimer);
    },2000);

    watchId=navigator.geolocation.watchPosition(onPosition,onPositionError,{enableHighAccuracy:true,maximumAge:1000,timeout:10000});

    // GPS弱いアラート監視
    gpsWeakTimer = setInterval(()=>{
      if(!tracking) return;
      const since = Date.now()-lastFixTime;
      if(since>15000 && !weakGpsWarned){ weakGpsWarned=true; toast('GPS信号が弱いです'); enqueueSpeech(['GPS信号が弱いです']); }
    },3000);
  }

  function stopTracking(){
    if(!tracking) return;
    tracking=false;
    navigator.geolocation.clearWatch?.(watchId); watchId=null;
    clearInterval(startupSweepTimer); clearInterval(gpsWeakTimer);
    start.disabled=false; stop.disabled=true; fabStop.style.display='none'; $recBadge.style.display='none';
    rotateMap(0); $compass.style.display='none';
    unlockTTS(); enqueueSpeech(['評価を終了します']);
    saveGpx.disabled=false; saveGeo.disabled=false;
  }
  window.__stopTracking = stopTracking; // inline用

  // イベント割当（touch と click の両方/FABは多重補足対策）
  start.addEventListener('click', startTracking, {passive:true});
  stop .addEventListener('click', stopTracking , {passive:true});
  // タッチ端末での取りこぼし対策（直接停止を呼ぶ）
  stop .addEventListener('touchstart', (e)=>{ e.preventDefault(); stopTracking(); }, {passive:false});
  ['touchstart','touchend','click'].forEach(t=>{
    fabStop.addEventListener(t, e=>{ e.stopPropagation(); if(t==='click'||t==='touchend') stopTracking(); }, {passive:true});
  });

  document.getElementById('recenter').addEventListener('click',()=>{ if(lastLatLng) centerOnVisible(L.latLng(lastLatLng)); });

  /* ===== チェックポイント ===== */
  const cpBtn=document.getElementById('cp'); const withMemo=document.getElementById('withMemo');
  const cps=[]; // {latlng:[lat,lng], memo, time}
  cpBtn.addEventListener('click', async ()=>{
    if(!lastLatLng){ toast('現在地が未取得です'); return; }
    let memo=''; if(withMemo.checked){ memo=prompt('メモ（空でも可）','')||''; }
    const here=L.latLng(lastLatLng);
    const m=L.marker(here,{icon:iconOrange}).addTo(checkpointLayer);
    m.bindPopup(`<b>チェックポイント</b><div>${escapeHTML(memo)}</div>`);
    cps.push({latlng:[here.lat,here.lng], memo, time:new Date().toISOString()});
    toast('チェックポイントを追加');
  });

  /* ===== 保存（GPX / GeoJSON） ===== */
  const saveGpx=document.getElementById('saveGpx');
  const saveGeo=document.getElementById('saveGeo');
  saveGpx.addEventListener('click',()=>{
    const gpx = buildGPX(trackLine.getLatLngs(), cps);
    downloadText(gpx, `track_${formatTs()}.gpx`, 'application/gpx+xml');
  });
  saveGeo.addEventListener('click',()=>{
    const gj = buildGeoJSON(trackLine.getLatLngs(), cps);
    downloadText(JSON.stringify(gj,null,2), `track_${formatTs()}.geo.json`, 'application/geo+json');
  });

  function buildGPX(latlngs, cps){
    const trkpts = latlngs.map(ll=>`<trkpt lat="${ll.lat}" lon="${ll.lng}"></trkpt>`).join('');
    const wpts   = cps.map(c=>`<wpt lat="${c.latlng[0]}" lon="${c.latlng[1]}"><name>${escapeXML(c.memo||'CP')}</name></wpt>`).join('');
    return `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="RouteAid">\n${wpts}<trk><name>drive</name><trkseg>${trkpts}</trkseg></trk></gpx>`;
  }
  function buildGeoJSON(latlngs, cps){
    return {
      type:'FeatureCollection',
      features:[
        {type:'Feature',properties:{type:'track'},geometry:{type:'LineString',coordinates:latlngs.map(ll=>[ll.lng,ll.lat])}},
        ...cps.map(c=>({type:'Feature',properties:{type:'checkpoint',memo:c.memo,time:c.time},geometry:{type:'Point',coordinates:[c.latlng[1],c.latlng[0]]}}))
      ]
    };
  }
  function downloadText(text, name, mime){
    const blob=new Blob([text],{type:mime});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href);
  }

  /* ===== Util ===== */
  function escapeHTML(s){ return String(s||'').replace(/[&<>\"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }
  function escapeXML(s){ return escapeHTML(s); }
  function formatTs(){ const d=new Date(); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`; }

  /* ===== GPS弱い監視タイマー ===== */
  let gpsWeakTimer=null;

  /* ===== PWA: Service Worker 登録 ===== */
  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('sw.js').then(reg=>{
      // 新版即時反映用
      if(reg.waiting){ reg.waiting.postMessage({type:'SKIP_WAITING'}); }
      reg.addEventListener('updatefound',()=>{
        const sw=reg.installing; sw?.addEventListener('statechange',()=>{ if(sw.state==='installed'){ reg.waiting?.postMessage({type:'SKIP_WAITING'}); } });
      });
      navigator.serviceWorker.addEventListener('controllerchange',()=> location.reload());
    }).catch(()=>{});
  }
})();
</script>
</body>
</html>
