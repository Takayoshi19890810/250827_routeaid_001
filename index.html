<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>実車評価支援ツール</title>
<link rel="stylesheet" href="leaflet.css" />
<style>
  html,body{height:100%;margin:0}
  #map{position:fixed; inset:0; background:#f2f2f2; transform-origin:center center; z-index:0;}
  #panel{
    position:fixed; left:10px; top:calc(10px + env(safe-area-inset-top));
    z-index:2147483000; background:#fff; padding:10px 12px; border-radius:12px;
    box-shadow:0 6px 24px rgba(0,0,0,.18); font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    min-width:300px; max-width:min(94vw,560px)
  }
  #panel h1{font-size:18px;margin:6px 0 12px}
  #panel .row{display:flex; gap:8px; align-items:center; margin:8px 0}
  #panel .row .grow{flex:1 1 auto}
  #panel .group{border-top:1px dashed #e5e7eb; margin-top:10px; padding-top:10px}
  .col{display:flex; flex-direction:column; gap:6px}
  .row{display:flex; gap:8px; align-items:center}
  .row>label{white-space:nowrap}
  .small{font-size:11px;color:#555}
  .grow{flex:1 1 auto;min-width:140px}
  button{padding:10px 14px; min-height:40px; border-radius:12px; cursor:pointer; border:1px solid #ddd; background:#fff;}
  select, input[type=range]{height:40px;border-radius:10px;border:1px solid #ddd;padding:0 8px}
  #start{background:#16a34a;color:#fff;border-color:#16a34a}
  #stop{background:#ef4444;color:#fff;border-color:#ef4444}
  #recenter{background:#0ea5e9;color:#fff;border-color:#0ea5e9}
  #cp{background:#f59e0b;color:#fff;border-color:#f59e0b}
  #saveGpx{background:#6366f1;color:#fff;border-color:#6366f1}
  #fabStop{position:fixed; right:calc(12px + env(safe-area-inset-right)); bottom:calc(12px + env(safe-area-inset-bottom));
    z-index:2147483200; display:none; width:84px;height:84px;border-radius:50%; box-shadow:0 12px 36px rgba(0,0,0,.28);
    border:none; background:#ef4444;color:#fff;font-size:16px;font-weight:700;}
  #recBadge{position:fixed; right:12px; top:calc(12px + env(safe-area-inset-top));
    z-index:2147483200; display:none; align-items:center; gap:6px;
    background:rgba(239,68,68,.95); color:#fff; padding:6px 10px; border-radius:9999px; font-weight:700;}
  #recBadge i{display:inline-block; width:10px;height:10px; border-radius:50%; background:#fff; animation:blink 1s infinite}
  @keyframes blink{0%,60%{opacity:1} 61%,100%{opacity:.2}}

  #compass{position:fixed; right:calc(14px + env(safe-area-inset-right)); top:calc(78px + env(safe-area-inset-top)); width:52px;height:52px; z-index:2147483200; display:none;}
  #compass canvas{width:100%;height:100%}

  .toast{position:fixed; left:50%; bottom:calc(14px + env(safe-area-inset-bottom)); transform:translateX(-50%);
    z-index:2147483500; background:rgba(0,0,0,.86); color:#fff; padding:10px 14px; border-radius:9999px; font-size:14px;}

/* === Panel toggle === */
#togglePanel{
  position:fixed;
  left:12px;
  top:12px;
  z-index:2147483300;
  background:#111;
  color:#fff;
  border:1px solid #111;
  border-radius:9999px;
  padding:8px 12px;
  font-weight:700;
  box-shadow:0 8px 24px rgba(0,0,0,.25);
}
#panel.is-hidden{ display:none; }
</style>
</head>
<body>
<div id="map"></div>

<div id="panel">
  <h1>実車評価支援ツール</h1>

  <!-- 複数ファイル入力 + 切替セレクタ -->
  <div class="group col">
    <div class="row">
      <label>評価データ</label>
      <input id="file" type="file" accept=".kml,.kmz,.gpx,.geojson,application/vnd.google-earth.kmz" class="grow" multiple />
      <select id="datasetSelect" class="grow">
        <option value="">（選択中のデータ）</option>
      </select>
    </div>
    <div class="row small">
      <span>※ KML/KMZ/GPX/GeoJSON からピンを読み込み。ルート用のピンは読み上げしません。</span>
    </div>
  </div>

  <div class="group col">
    <div class="row">
      <button id="start">追跡開始</button>
      <button id="stop" disabled>追跡終了</button>
      <button id="recenter">自車へ</button>
      <button id="cp" title="チェックポイント">CP</button>
    </div>
    <div class="row small">
      <label><input id="northUp" type="radio" name="dir" checked /> 北を上</label>
      <label><input id="headingUp" type="radio" name="dir" /> 進行方向を上</label>
      <label><input id="followMe" type="checkbox" checked /> 常に自車を中心</label>
    </div>
    <div class="row">
      <label>通知半径</label>
      <input id="radius" type="range" min="50" max="800" step="10" value="150" class="grow" />
      <span id="radiusVal">150m</span>
    </div>
    <div class="row">
      <label>再通知距離</label>
      <input id="renotify" type="range" min="50" max="1000" step="50" value="300" class="grow" />
      <span id="renotifyVal">300m</span>
    </div>
  </div>

  <div class="group col">
    <div class="row">
      <button id="saveGpx" disabled>GPX保存</button>
    </div>
    <div class="row small">
      <span>※ 追跡終了時にも保存確認が出ます。</span>
    </div>
  </div>

  <div class="group col">
    <div class="row small">
      <span>音声：端末の設定を使用（iOSは設定＞アクセシビリティ＞読み上げコンテンツ）</span>
    </div>
    <div class="row small">
      <span>GPS弱い時は通知。開始直後、半径内のポイントも読み上げ。</span>
    </div>
  </div>
</div>
<button id="togglePanel" aria-label="メニュー表示切替">メニュー</button>

<button id="fabStop" aria-label="緊急停止">停止</button>
<div id="recBadge"><i></i><span>REC</span></div>
<div id="compass"><canvas width="100" height="100"></canvas></div>

<script src="leaflet.js"></script>
<script src="jszip.min.js"></script>
<script src="togeojson.umd.js"></script>
<script>
'use strict';

// ===== 地図セットアップ =====
const map = L.map('map', { zoomControl:false, preferCanvas:true }).setView([35.681236,139.767125], 15);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors', maxZoom: 19
}).addTo(map);

// UI要素
const fileInput = document.getElementById('file');
const datasetSelect = document.getElementById('datasetSelect');
const start = document.getElementById('start');
const stop = document.getElementById('stop');
const fabStop = document.getElementById('fabStop');
const recBadge = document.getElementById('recBadge');
const northUp = document.getElementById('northUp');
const headingUp = document.getElementById('headingUp');
const followMe = document.getElementById('followMe');
const radius = document.getElementById('radius');
const radiusVal = document.getElementById('radiusVal');
const renotify = document.getElementById('renotify');
const renotifyVal = document.getElementById('renotifyVal');
const saveGpx = document.getElementById('saveGpx');
const recCanvas = document.querySelector('#compass canvas');
const $compass = document.getElementById('compass');

const panel = document.getElementById('panel');
const togglePanelBtn = document.getElementById('togglePanel');

// レイヤ
const trackLine = L.polyline([], { color:'#ef4444', weight:4 }).addTo(map);
const meMarker = L.circleMarker([0,0], { radius:7, color:'#ef4444', fillColor:'#ef4444', fillOpacity:1 }).addTo(map);
const radiusCircle = L.circle([0,0], { radius:150, color:'#0ea5e9', weight:1, fillColor:'#0ea5e9', fillOpacity:.08 }).addTo(map);

// チェックポイントと評価ポイント
let cps = []; // {lat, lng, note, t}
let pois = []; // 読み上げ対象のポイント
let routePins = []; // ルート用ピン（読み上げない）

let tracking=false, watchId=null, heading=0, lastFixTime=0;
let startupSweepTimer=null, gpsWeakTimer=null;
let lastReadMap = new Map(); // id -> lastReadDistance

function formatTs(){
  const d=new Date();
  const pad=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}

function toast(msg){
  const t=document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t);
  setTimeout(()=>{ t.remove(); }, 2200);
}

function rotateMap(deg){
  document.getElementById('map').style.transform=`rotate(${deg}deg)`;
}

function unlockTTS(){
  try{ window.speechSynthesis?.cancel(); }catch{}
}
function enqueueSpeech(texts){
  try{
    for(const tx of texts){
      const u = new SpeechSynthesisUtterance(String(tx));
      window.speechSynthesis?.speak(u);
    }
  }catch{}
}

function downloadText(text, name, mime){
  const blob=new Blob([text], {type:mime||'text/plain'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}

function buildGPX(latlngs, cps){
  const esc = s=>String(s).replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]||c));
  const trkpts = latlngs.map(ll=>`<trkpt lat="${ll.lat}" lon="${ll.lng}"><time>${new Date().toISOString()}</time></trkpt>`).join('');
  const wpts = (cps||[]).map(c=>`<wpt lat="${c.lat}" lon="${c.lng}"><name>${esc(c.note||'CP')}</name></wpt>`).join('');
  return `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="evaltool" xmlns="http://www.topografix.com/GPX/1/1">${wpts}<trk><name>track</name><trkseg>${trkpts}</trkseg></trk></gpx>`;
}

// ===== データ読み込み（KML/KMZ/GPX/GeoJSON） =====
const datasets = new Map(); // name -> {pois, routePins}

function addPoi(lat,lng,prop){
  const m=L.circleMarker([lat,lng], {radius:8, color:'#10b981', fillColor:'#10b981', fillOpacity:1}).addTo(map);
  m.bindTooltip(prop?.name||prop?.description||'');
  pois.push({lat,lng, note:prop?.name||prop?.description||''});
}
function addRoutePin(lat,lng,prop){
  const m=L.circleMarker([lat,lng], {radius:6, color:'#64748b', fillColor:'#e2e8f0', fillOpacity:1}).addTo(map);
  m.bindTooltip(prop?.name||'');
  routePins.push({lat,lng});
}

async function handleFiles(files){
  for(const f of files){
    const buf = await f.arrayBuffer();
    let name = f.name;
    let kmlText = '';

    if(/\.kmz$/i.test(name)){
      // KMZ: ZIPからKML抽出（UMDのJSZipをグローバル利用）
      try{
        const zip = await JSZip.loadAsync(buf);
        const kmlEntry = Object.keys(zip.files).find(k=>/\.kml$/i.test(k));
        if(kmlEntry){
          kmlText = await zip.files[kmlEntry].async('string');
        } else {
          throw new Error('KMZ内にKMLが見つかりません');
        }
      }catch(e){ console.error(e); toast('KMZの展開に失敗'); }
    } = await import('./jszip.min.js');
        const zip = await JSZip.loadAsync(buf);
        const kmlEntry = Object.keys(zip.files).find(k=>/\.kml$/i.test(k));
        if(kmlEntry){
          kmlText = await zip.files[kmlEntry].async('string');
        }
      }catch(e){ console.error(e); toast('KMZの展開に失敗'); }
    }else{
      const text = new TextDecoder('utf-8').decode(buf);
      if(/<kml/i.test(text)) kmlText = text;
      else if(/<gpx/i.test(text)){
        // GPX: wpt -> 読み上げ対象, trk -> ルート
        try{
          const dom = new DOMParser().parseFromString(text, 'application/xml');
          dom.querySelectorAll('wpt').forEach(w=> addPoi(parseFloat(w.getAttribute('lat')), parseFloat(w.getAttribute('lon')), {name:w.querySelector('name')?.textContent||''}));
          dom.querySelectorAll('trkseg trkpt').forEach(tp=> addRoutePin(parseFloat(tp.getAttribute('lat')), parseFloat(tp.getAttribute('lon'))));
          toast(`${name} を読み込み`);
        }catch(e){ console.error(e); toast('GPX読込失敗'); }
        continue;
      }else{
        // GeoJSON: FeatureCollection -> Pointのみ読み上げ
        try{
          const gj = JSON.parse(text);
          if(gj?.type==='FeatureCollection'){
            for(const feat of gj.features||[]){
              const g=feat.geometry; const p=feat.properties||{};
              if(g?.type==='Point' && Array.isArray(g.coordinates)){
                addPoi(g.coordinates[1], g.coordinates[0], p);
              }
            }
            toast(`${name} を読み込み`);
          }
        }catch{ /* 無視 */ }
        continue;
      }
    }

    if(kmlText){
      try{
        const dom = new DOMParser().parseFromString(kmlText, 'text/xml');
        const kml = toGeoJSON.kml(dom);
        // スタイル名に route が含まれるものはルート扱い、それ以外は読み上げ対象
        for(const feat of (kml.features||[])){
          if(feat.geometry?.type==='Point'){
            const p=feat.properties||{}; const name=p.name||p.description||''; const style=(p.styleUrl||'')+(p.icon||'');
            const [lng,lat] = feat.geometry.coordinates;
            if(/route|line|path/i.test(style)) addRoutePin(lat,lng,{name});
            else addPoi(lat,lng,{name});
          }
        }
        toast(`${name} を読み込み`);
      }catch(e){ console.error(e); toast('KML読込失敗'); }
    }
  }
}

fileInput.addEventListener('change', e=>{
  handleFiles(e.target.files);
});

// データセット切替（将来拡張用）
datasetSelect.addEventListener('change', e=>{
  // ここでは最小実装：本体配列を差し替えるならこの辺で
});

// 半径UI
radius.addEventListener('input', ()=>{ radiusVal.textContent = `${radius.value}m`; radiusCircle.setRadius(+radius.value); });
renotify.addEventListener('input', ()=>{ renotifyVal.textContent = `${renotify.value}m`; });

// 位置追跡
function onPos(p){
  const {latitude:lat, longitude:lng, heading:hdg, speed} = p.coords;
  lastFixTime = Date.now();
  meMarker.setLatLng([lat,lng]);
  radiusCircle.setLatLng([lat,lng]);
  if(followMe.checked){ map.setView([lat,lng], map.getZoom(), {animate:false}); }
  if(headingUp.checked){ rotateMap(-(hdg||0)); $compass.style.display='block'; drawCompass(hdg||0); } else { rotateMap(0); $compass.style.display='none'; }

  if(tracking){
    trackLine.addLatLng([lat,lng]);
    checkAnnounce([lat,lng]);
  }
}
function onPosErr(err){ console.warn(err); }

function startTracking(){
  if(tracking) return;
  tracking=true; lastReadMap.clear(); trackLine.setLatLngs([]);
  start.disabled=true; stop.disabled=false; fabStop.style.display='block'; recBadge.style.display='flex';
  enqueueSpeech(['追跡を開始します']);

  // 開始直後、半径内のポイントを読み上げ
  sweepAnnounce();

  watchId = navigator.geolocation.watchPosition(onPos, onPosErr, { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
  startupSweepTimer = setInterval(sweepAnnounce, 4000);
  gpsWeakTimer = setInterval(()=>{
    if(Date.now()-lastFixTime>7000){ toast('GPS信号が弱いです'); enqueueSpeech(['GPS信号が弱いです']); }
  }, 3000);
}

function stopTracking(){
    if(!tracking) return;
    tracking=false;
    navigator.geolocation.clearWatch?.(watchId); watchId=null;
    clearInterval(startupSweepTimer); clearInterval(gpsWeakTimer);
    start.disabled=false; stop.disabled=true; fabStop.style.display='none'; document.getElementById('recBadge').style.display='none';
    rotateMap(0); $compass.style.display='none';
    unlockTTS(); enqueueSpeech(['評価を終了します']);

// 追跡終了後のGPX保存フロー（確認 → ファイル名入力 → 保存）
try{
  const latlngs = trackLine.getLatLngs();
  if(latlngs && latlngs.length){
    const doSave = confirm('GPXを保存しますか？');
    if(doSave){
      const defaultName = `track_${formatTs()}.gpx`;
      const name = prompt('保存するファイル名を入力してください（.gpx）', defaultName) || defaultName;
      const gpx = buildGPX(latlngs, cps || []);
      downloadText(gpx, name.endsWith('.gpx') ? name : `${name}.gpx`, 'application/gpx+xml');
      toast('GPXを保存しました');
    }
  }else{
    toast('保存できる軌跡がありません');
  }
}catch(e){
  console.error(e);
  toast('保存に失敗しました');
}

    cpBtn.disabled=true;
  }
  
start.addEventListener('click', startTracking);
stop.addEventListener('click', stopTracking);
fabStop.addEventListener('click', stopTracking);

// 明示保存ボタン（残す）
saveGpx.addEventListener('click', ()=>{
  const latlngs = trackLine.getLatLngs();
  if(!latlngs || !latlngs.length){ toast('保存できる軌跡がありません'); return; }
  const name = `track_${formatTs()}.gpx`;
  const gpx = buildGPX(latlngs, cps||[]);
  downloadText(gpx, name, 'application/gpx+xml');
  toast('GPXを保存しました');
});

// チェックポイント
const cpBtn = document.getElementById('cp');
cpBtn.addEventListener('click', ()=>{
  navigator.geolocation.getCurrentPosition(p=>{
    const note = confirm('メモを入力しますか？') ? (prompt('メモを入力','')||'') : '';
    const {latitude:lat, longitude:lng} = p.coords;
    cps.push({lat,lng,note,t:Date.now()});
    L.circleMarker([lat,lng], {radius:8, color:'#f59e0b', fillColor:'#f59e0b', fillOpacity:1}).addTo(map).bindTooltip(note||'CP');
    toast('CPを追加');
  });
});

// 進行方向コンパス
function drawCompass(deg){
  const ctx=recCanvas.getContext('2d');
  const w=recCanvas.width, h=recCanvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save();
  ctx.translate(w/2,h/2);
  ctx.rotate(deg*Math.PI/180);
  ctx.beginPath(); ctx.moveTo(0,-40); ctx.lineTo(6,0); ctx.lineTo(-6,0); ctx.closePath();
  ctx.fillStyle='#ef4444'; ctx.fill();
  ctx.restore();
}

function dist(a,b){
  const R=6371000;
  const toRad=x=>x*Math.PI/180;
  const dLat=toRad(b[0]-a[0]); const dLng=toRad(b[1]-a[1]);
  const la1=toRad(a[0]); const la2=toRad(b[0]);
  const s = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
}

function checkAnnounce(my){
  const r = +radius.value;
  for(let i=0;i<pois.length;i++){
    const p=pois[i];
    const d = dist(my,[p.lat,p.lng]);
    const last = lastReadMap.get(i)||Infinity;
    if(d<=r && d>=50 && (d<=r && (isNaN(last) || last>=+renotify.value))){
      enqueueSpeech([p.note||'評価ポイント']);
      lastReadMap.set(i,0);
    }else if(d>r){
      lastReadMap.set(i,Math.min(20000, d));
    }
  }
}

function sweepAnnounce(){
  navigator.geolocation.getCurrentPosition(p=>{
    const my=[p.coords.latitude,p.coords.longitude];
    const r=+radius.value;
    let any=false;
    pois.forEach((poi,idx)=>{
      const d=dist(my,[poi.lat,poi.lng]);
      if(d<=r){ enqueueSpeech([poi.note||'評価ポイント']); lastReadMap.set(idx,0); any=true; }
    });
    if(any) toast('開始直後の半径内ポイントを読み上げ');
  });
}

// 再センター
const recenter = document.getElementById('recenter');
recenter.addEventListener('click', ()=>{
  navigator.geolocation.getCurrentPosition(p=>{
    map.setView([p.coords.latitude,p.coords.longitude], Math.max(16, map.getZoom()))
  });
});

// Panel toggle
document.getElementById('togglePanel').addEventListener('click', ()=>{
  document.getElementById('panel').classList.toggle('is-hidden');
});

</script>
</body>
</html>
