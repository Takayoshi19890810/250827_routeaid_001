<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Route Aid – 追跡＆軌跡保存</title>
  <link rel="stylesheet" href="./leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { padding: .5rem .75rem; display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; box-shadow: 0 1px 0 rgba(0,0,0,.08); }
    header .title { font-weight: 700; margin-right: .5rem; }
    header .sep { width: 1px; height: 24px; background: #e5e7eb; margin: 0 .25rem; }
    header button, header input, header label { font-size: 14px; }
    header button { padding: .5rem .7rem; border-radius: 10px; border: 1px solid #e5e7eb; background: #fff; cursor: pointer; }
    header button.primary { background: #111827; color: white; border-color: #111827; }
    header button.primary.running { background: #16a34a; border-color: #16a34a; animation: pulseBtn 1s infinite alternate; }
    @keyframes pulseBtn { from { opacity: .85; } to { opacity: 1; transform: scale(1.05); } }
    header button.destructive { background: #dc2626; color: white; border-color: #dc2626; }
    header button:disabled { opacity: .5; cursor: not-allowed; }
    header .pill { padding: .35rem .6rem; border-radius: 999px; background: #f3f4f6; }

    /* 状態ピル */
    .status-pill { display:inline-flex; align-items:center; gap:6px; padding:.35rem .6rem; border-radius:999px; background:#f3f4f6;}
    .status-pill .dot { width:8px; height:8px; border-radius:999px; background:#9ca3af; }
    .status-running { background:#fee2e2; color:#b91c1c; }
    .status-running .dot { background:#ef4444; animation: pulse 1s ease-in-out infinite alternate; }
    .status-paused { background:#fffbeb; color:#92400e; }
    .status-paused .dot { background:#f59e0b; }
    .status-stopped { background:#e5e7eb; color:#374151; }
    .status-idle { background:#f3f4f6; color:#374151; }
    @keyframes pulse { from { opacity:.6; transform: scale(1); } to { opacity:1; transform: scale(1.25);} }

    #map { width: 100%; height: 100%; }
    .stat { font-variant-numeric: tabular-nums; }
    .toast { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); background: rgba(0,0,0,.85); color:#fff; padding: 10px 14px; border-radius: 10px; font-size: 13px; z-index: 9999; }

    /* RECバッジ */
    .rec-badge { position: fixed; top: 8px; right: 8px; background: rgba(239,68,68,.95); color: #fff; padding: 6px 10px; border-radius: 999px; font-weight: 700; font-size: 12px; z-index: 2000; box-shadow: 0 2px 10px rgba(0,0,0,.15); letter-spacing: .5px; }
    .rec-badge .dot { display:inline-block; width:8px; height:8px; border-radius:999px; background:#fff; margin-right:6px; animation: recblink 1s infinite alternate; }
    .hidden { display: none; }
    @keyframes recblink { from { opacity:.7; transform: scale(.9);} to { opacity:1; transform: scale(1.1);} }
  </style>
  <link rel="manifest" href="./manifest.webmanifest" />
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.warn);
      });
    }
  </script>
</head>
<body>
<div id="app">
  <header>
    <span class="title">Route Aid</span>
    <span class="sep"></span>

    <button id="btnStart" class="primary">▶ 追跡開始</button>
    <button id="btnPause" disabled>⏸ 一時停止</button>
    <button id="btnResume" disabled>▶ 再開</button>
    <button id="btnStop" class="destructive" disabled>■ 停止</button>

    <span class="sep"></span>

    <span class="pill stat">距離: <span id="dist">0.00</span> km</span>
    <span class="pill stat">ポイント: <span id="pts">0</span></span>
    <span class="pill stat">経過: <span id="elapsed">00:00:00</span></span>

    <span id="runStatus" class="status-pill status-idle" title="追跡の状態">
      <span class="dot"></span>
      <span id="runStatusText">待機中</span>
    </span>

    <span class="sep"></span>

    <label>通知半径(m): <input id="notifyRadius" type="number" value="200" min="10" step="10" style="width:80px"/></label>

    <span class="sep"></span>

    <button id="btnVoiceTest" title="音声テスト">🔊 音声テスト</button>

    <span class="sep"></span>

    <label>ファイル名: <input id="fname" placeholder="Track_YYYYMMDD_HHMMSS" style="width: 190px"/></label>
    <button id="btnSaveGPX" disabled>💾 GPX保存</button>
    <button id="btnSaveGeoJSON" disabled>💾 GeoJSON保存</button>

    <button id="btnPickDir" title="対応ブラウザのみ（Chrome/Edge等）">📁 保存先フォルダ指定</button>
    <span id="dirLabel" class="pill" title="File System Access API">未指定</span>
  </header>
  <div id="recBadge" class="rec-badge hidden"><span class="dot"></span>REC 追跡中</div>
  <div id="map"></div>
</div>

<script src="./leaflet.js"></script>
<script>
  // ====== 状態 ======
  let map, currentMarker, trackLine, notifyCircle;
  let startTime = null;
  let elapsedTimer = null;
  let watchId = null;
  let points = [];
  let distMeters = 0;
  let following = true;
  let dirHandle = null;

  // 近接読み上げ：開始後、最初の測位で実行
  let initialPOIAnnounced = false;
  const POIS = window.ROUTE_AID_POIS || [];

  // ====== 音声ユーティリティ ======
  function pickJaVoice(){
    try{
      const synth = window.speechSynthesis; if(!synth) return null;
      const vs = synth.getVoices ? synth.getVoices() : [];
      const ja = vs.filter(v => (v.lang||'').toLowerCase().startsWith('ja'));
      return ja[0] || vs[0] || null;
    }catch(_){ return null; }
  }
  function speak(text){
    try{
      if(!('speechSynthesis' in window)) { toast('音声合成に未対応のブラウザです'); return; }
      const synth = window.speechSynthesis;
      try { synth.cancel(); if (synth.resume) synth.resume(); } catch(_){}
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ja-JP';
      u.rate = 0.95;
      const v = pickJaVoice(); if (v) u.voice = v;
      synth.speak(u);
    }catch(e){ console.warn('speech fail', e); }
  }
  function speakThen(text, next){
    try{
      if(!('speechSynthesis' in window)) { next && next(); return; }
      const synth = window.speechSynthesis;
      try { synth.cancel(); if (synth.resume) synth.resume(); } catch(_){}
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ja-JP';
      u.rate = 0.95;
      const v = pickJaVoice(); if (v) u.voice = v;
      u.onend = () => setTimeout(()=> next && next(), 120);
      synth.speak(u);
    }catch(e){ console.warn('speechThen fail', e); next && next(); }
  }
  if ('speechSynthesis' in window) {
    const warmup = () => { try { window.speechSynthesis.getVoices(); } catch(_){} };
    warmup();
    window.speechSynthesis.onvoiceschanged = warmup;
  }

  // ====== IndexedDB 簡易ラッパ ======
  function openDB(){
    return new Promise((res,rej)=>{
      const req = indexedDB.open('RouteAidDB',1);
      req.onupgradeneeded=e=>{e.target.result.createObjectStore('tracks');};
      req.onsuccess=e=>res(e.target.result);
      req.onerror=e=>rej(e);
    });
  }
  async function saveBackup(){
    try{ const db=await openDB(); const tx=db.transaction('tracks','readwrite'); tx.objectStore('tracks').put({points,distMeters,startTime},'current'); }catch(e){console.warn('backup failed',e)}
  }
  async function loadBackup(){
    try{ const db=await openDB(); const tx=db.transaction('tracks','readonly'); const req=tx.objectStore('tracks').get('current'); return await new Promise(r=>{req.onsuccess=()=>r(req.result); req.onerror=()=>r(null);}); }catch(e){return null;}
  }
  async function clearBackup(){ try{ const db=await openDB(); const tx=db.transaction('tracks','readwrite'); tx.objectStore('tracks').delete('current'); }catch(e){}

  // ====== 初期化 ======
  function init() {
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    map.setView([35.681236, 139.767125], 13);
    trackLine = L.polyline([], { color: 'red', weight: 4, opacity: 0.9 }).addTo(map);

    document.getElementById('btnStart').addEventListener('click', startTracking);
    document.getElementById('btnPause').addEventListener('click', pauseTracking);
    document.getElementById('btnResume').addEventListener('click', resumeTracking);
    document.getElementById('btnStop').addEventListener('click', stopTracking);
    document.getElementById('btnSaveGPX').addEventListener('click', () => saveTrack('gpx'));
    document.getElementById('btnSaveGeoJSON').addEventListener('click', () => saveTrack('geojson'));
    document.getElementById('btnPickDir').addEventListener('click', pickDirectory);
    document.getElementById('btnVoiceTest').addEventListener('click', ()=> speak('音声テストです'));

    document.getElementById('notifyRadius').addEventListener('change', ()=>{
      const r = parseFloat(document.getElementById('notifyRadius').value)||200;
      if (notifyCircle) notifyCircle.setRadius(r);
    });

    document.getElementById('fname').value = defaultFileName();

    loadBackup().then(data=>{
      if(data && data.points && data.points.length>0){
        if(confirm('前回の追跡データがあります。復元しますか？')){
          points=data.points; distMeters=data.distMeters; startTime=data.startTime?new Date(data.startTime):null;
          trackLine.setLatLngs(points.map(p=>[p.lat,p.lng]));
          updateStats();
        } else { clearBackup(); }
      }
    });
  }

  // ====== UIユーティリティ ======
  function toast(msg, ms = 1600) { const t = document.createElement('div'); t.className = 'toast'; t.textContent = msg; document.body.appendChild(t); setTimeout(() => t.remove(), ms); }
  function defaultFileName() { const d = new Date(); const pad = n => String(n).padStart(2, '0'); return `Track_${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`; }

  // ====== 追跡制御 ======
  function startTracking() {
    if (!('geolocation' in navigator)) { toast('位置情報未対応'); return; }
    points = []; distMeters = 0; updateStats(); trackLine.setLatLngs([]);
    if (currentMarker) currentMarker.remove();

    // クリック直後に開始アナウンス（ユーザ操作に紐づくのでiOSでも通る）
    speak('これから評価開始します');

    watchId = navigator.geolocation.watchPosition(onPos, onErr, {enableHighAccuracy:true,maximumAge:1000,timeout:20000});
    startTime=new Date(); if(elapsedTimer) clearInterval(elapsedTimer); elapsedTimer=setInterval(updateElapsed,1000);
    setButtons({ running:true }); setRunStatus('running');
    document.getElementById('btnStart').classList.add('running');
    document.getElementById('recBadge').classList.remove('hidden');
    toast('評価を開始します（追跡開始）');
  }

  function onPos(pos){
    const {latitude:lat,longitude:lng}=pos.coords; const t=new Date();
    const last=points.length?points[points.length-1]:null;
    const p={lat,lng,t:t.toISOString()}; points.push(p);
    if(last) distMeters+=haversine(last.lat,last.lng,lat,lng);

    trackLine.addLatLng([lat,lng]);
    if(!currentMarker) currentMarker=L.marker([lat,lng]).addTo(map); else currentMarker.setLatLng([lat,lng]);
    if(following) map.setView([lat,lng],Math.max(map.getZoom(),16),{animate:false});

    // 位置周囲の影（通知円）
    const radius = parseFloat(document.getElementById('notifyRadius').value)||200;
    if(notifyCircle) { notifyCircle.setLatLng([lat,lng]); notifyCircle.setRadius(radius); }
    else { notifyCircle=L.circle([lat,lng],{radius,fillColor:'#3b82f6',fillOpacity:0.15,color:'#2563eb',weight:1}).addTo(map); }

    // 開始後最初の測位で、半径内POIを近い順に読み上げ
    if(!initialPOIAnnounced){
      speakThen('範囲内のポイントをお知らせします', ()=> announceNearbyWithinRadius(lat,lng,radius));
      initialPOIAnnounced = true;
    }

    updateStats();
    saveBackup();
  }

  function onErr(err){console.warn('Geolocation error:',err); toast('位置情報取得失敗');}

  function pauseTracking(){ if(watchId!=null){navigator.geolocation.clearWatch(watchId); watchId=null; if(elapsedTimer) {clearInterval(elapsedTimer); elapsedTimer=null;} setButtons({paused:true}); setRunStatus('paused'); toast('一時停止');} }

  function resumeTracking(){ if(watchId==null){watchId=navigator.geolocation.watchPosition(onPos,onErr,{enableHighAccuracy:true,maximumAge:1000,timeout:20000}); if(!startTime) startTime=new Date(); if(elapsedTimer) clearInterval(elapsedTimer); elapsedTimer=setInterval(updateElapsed,1000); setButtons({running:true}); setRunStatus('running'); toast('追跡を再開');} }

  function stopTracking(){ if(watchId!=null){navigator.geolocation.clearWatch(watchId); watchId=null;} if(elapsedTimer){clearInterval(elapsedTimer); elapsedTimer=null;} setButtons({stopped:true}); setRunStatus('stopped'); document.getElementById('btnStart').classList.remove('running'); document.getElementById('recBadge').classList.add('hidden'); toast('停止しました。保存できます'); speak('評価を終了します。データを忘れずに保存してください'); }

  function setButtons(state){
    const s=document.getElementById('btnStart'),p=document.getElementById('btnPause'),r=document.getElementById('btnResume'),st=document.getElementById('btnStop'),g=document.getElementById('btnSaveGPX'),j=document.getElementById('btnSaveGeoJSON');
    if(state.running){s.disabled=true;p.disabled=false;r.disabled=true;st.disabled=false;g.disabled=true;j.disabled=true;}
    else if(state.paused){s.disabled=true;p.disabled=true;r.disabled=false;st.disabled=false;g.disabled=true;j.disabled=true;}
    else if(state.stopped){s.disabled=false;p.disabled=true;r.disabled=true;st.disabled=true;g.disabled=false;j.disabled=false;}
    else{s.disabled=false;p.disabled=true;r.disabled=true;st.disabled=true;g.disabled=true;j.disabled=true;}
  }

  function updateStats(){ document.getElementById('pts').textContent=String(points.length); document.getElementById('dist').textContent=(distMeters/1000).toFixed(2); const now=new Date(); if(startTime){ const sec=Math.floor((now-startTime)/1000); const h=String(Math.floor(sec/3600)).padStart(2,'0'); const m=String(Math.floor((sec%3600)/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); document.getElementById('elapsed').textContent=`${h}:${m}:${s}`; } }

  // ====== 近接案内 ======
  function announceNearbyWithinRadius(lat, lng, radius){
    if (!POIS || !POIS.length) { speak('範囲内のポイントはありません'); return; }
    const withD = POIS.map(o=>({ ...o, d: haversine(lat, lng, o.lat, o.lng) }))
                      .filter(o=> o.d <= radius)
                      .sort((a,b)=> a.d - b.d);
    if (!withD.length) { speak('範囲内のポイントはありません'); return; }
    let i=0; const sayNext=()=>{ if(i>=withD.length) return; const o=withD[i++]; const m = `${o.name || 'スポット'}、距離 ${Math.round(o.d)} メートル` + (o.note? `。メモ、${o.note}`: ''); speak(m); setTimeout(sayNext, 700); }; sayNext();
  }

  // ====== 保存処理 ======
  async function saveTrack(fmt){ if(points.length<2){toast('保存できる軌跡がありません');return;} const nameRaw=(document.getElementById('fname').value||defaultFileName()).trim(); const safe=nameRaw.replace(/[^\w\\-_.]/g,'_'); const filename=fmt==='gpx'?`${safe}.gpx`:`${safe}.geojson`; try{let dataStr,mime;if(fmt==='gpx'){dataStr=buildGPX(points);mime='application/gpx+xml';}else{dataStr=JSON.stringify(buildGeoJSON(points),null,2);mime='application/geo+json';} if(dirHandle&&(await verifyPermission(dirHandle,true))){const fileHandle=await dirHandle.getFileHandle(filename,{create:true}); const writable=await fileHandle.createWritable(); await writable.write(new Blob([dataStr],{type:mime})); await writable.close(); toast(`保存しました: ${filename}`);} else {const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([dataStr],{type:mime})); a.download=filename; document.body.appendChild(a); a.click(); a.remove(); toast('ダウンロードを開始しました');}}catch(e){console.error(e); toast('保存に失敗しました');}}

  function buildGeoJSON(pts){return {type:'FeatureCollection',features:[{type:'Feature',properties:{name:'Recorded Track',points:pts.length,distance_m:Math.round(distMeters)},geometry:{type:'LineString',coordinates:pts.map(p=>[p.lng,p.lat])}}]};}
  function buildGPX(pts){const esc=s=>s.replace(/[<&>]/g,c=>({'<':'&lt;','&':'&amp;','>':'&gt;'}[c])); const trkpts=pts.map(p=>`      <trkpt lat=\"${p.lat}\" lon=\"${p.lng}\">\\n        <time>${p.t}</time>\\n      </trkpt>`).join('\\n'); return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n`+`<gpx version=\"1.1\" creator=\"Route Aid\" xmlns=\"http://www.topografix.com/GPX/1/1\">\\n`+`  <trk>\\n`+`    <name>${esc(document.getElementById('fname').value||'Recorded Track')}</name>\\n`+`    <trkseg>\\n`+`${trkpts}\\n`+`    </trkseg>\\n`+`  </trk>\\n`+`</gpx>`;}

  // ====== FS Access & 計算 ======
  async function pickDirectory(){ if(!('showDirectoryPicker' in window)){ toast('未対応ブラウザ'); return; } try{ dirHandle=await window.showDirectoryPicker({mode:'readwrite'}); if(await verifyPermission(dirHandle,true)){ document.getElementById('dirLabel').textContent='指定済み'; toast('保存先フォルダを指定しました'); } }catch(e){ if(e && e.name!=='AbortError') console.warn(e); }
  async function verifyPermission(fileHandle,withWrite){ const opts={}; if(withWrite) opts.mode='readwrite'; if((await fileHandle.queryPermission(opts))==='granted') return true; if((await fileHandle.requestPermission(opts))==='granted') return true; return false; }
  function haversine(lat1,lon1,lat2,lon2){ const R=6371000; const toRad=d=>d*Math.PI/180; const dLat=toRad(lat2-lat1); const dLon=toRad(lon2-lon1); const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2; const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); return R*c; }

  // ====== ステータス表示 ======
  function setRunStatus(mode){ const pill=document.getElementById('runStatus'); const text=document.getElementById('runStatusText'); if(!pill||!text) return; pill.classList.remove('status-idle','status-running','status-paused','status-stopped'); if(mode==='running'){ pill.classList.add('status-running'); text.textContent='追跡中'; document.title='● 追跡中 – Route Aid'; } else if(mode==='paused'){ pill.classList.add('status-paused'); text.textContent='一時停止'; document.title='⏸ 一時停止 – Route Aid'; } else if(mode==='stopped'){ pill.classList.add('status-stopped'); text.textContent='停止'; document.title='Route Aid – 追跡＆軌跡保存'; } else { pill.classList.add('status-idle'); text.textContent='待機中'; document.title='Route Aid – 追跡＆軌跡保存'; } }

  function updateElapsed(){ if(!startTime) return; const now=new Date(); const sec=Math.floor((now-startTime)/1000); const h=String(Math.floor(sec/3600)).padStart(2,'0'); const m=String(Math.floor((sec%3600)/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); document.getElementById('elapsed').textContent=`${h}:${m}:${s}`; }

  // 起動
  init();
  setRunStatus('idle');
</script>
</body>
</html>
