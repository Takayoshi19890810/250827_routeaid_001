<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>実車評価支援ツール</title>
<link rel="stylesheet" href="leaflet.css?v=250839" />
<style>
  html,body,#map{height:100%;margin:0}
  #map{background:#f2f2f2}
  /* 左上のカードUI */
  #panel{
    position:absolute;left:10px;top:10px;z-index:1000;
    background:#fff;padding:10px 12px;border-radius:14px;
    box-shadow:0 6px 24px rgba(0,0,0,.18);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    min-width:300px;max-width:min(94vw,460px)
  }
  #panel h1{margin:0 0 8px;font-size:14px;font-weight:700}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
  .small{font-size:11px;color:#555}
  button{padding:6px 10px;border-radius:10px;cursor:pointer;border:1px solid #ddd;background:#fff}
  #track{background:#16a34a;color:#fff;border-color:#16a34a}
  #stop{background:#ef4444;color:#fff;border-color:#ef4444}
  #recenter{background:#0ea5e9;color:#fff;border-color:#0ea5e9}
  #checkpoint{background:#f59e0b;color:#fff;border-color:#f59e0b}
  #export{background:#6366f1;color:#fff;border-color:#6366f1}
  /* 右下の現在地ボタン */
  #fab-recenter{
    position:absolute;right:14px;bottom:14px;z-index:1000;
    width:50px;height:50px;border-radius:50%;
    display:grid;place-items:center;background:#0ea5e9;color:#fff;
    font-size:20px;border:none;box-shadow:0 6px 24px rgba(0,0,0,.18)
  }
  /* 追跡中バッジ */
  #recBadge{
    position:absolute;right:12px;top:12px;z-index:1001;display:none;align-items:center;gap:6px;
    background:rgba(239,68,68,.95);color:#fff;padding:6px 10px;border-radius:9999px;
    box-shadow:0 6px 24px rgba(0,0,0,.18);font-size:12px
  }
  .dot{width:10px;height:10px;border-radius:50%;background:#fff;animation:blink 1s infinite}
  @keyframes blink{0%,60%{opacity:1}61%,100%{opacity:.25}}
</style>
</head>
<body>
<div id="map"></div>
<div id="recBadge"><span class="dot"></span>追跡中</div>

<div id="panel">
  <h1>実車評価支援ツール</h1>

  <!-- Safariでも確実に出る素のファイル入力 -->
  <div class="row">
    <input id="file" type="file" accept=".kml,.kmz,application/vnd.google-earth.kml+xml,application/vnd.google-earth.kmz" />
    <button id="clear">クリア</button>
    <span id="fname" class="small">（未選択）</span>
  </div>

  <div class="row">
    <button id="track">追跡開始</button>
    <button id="stop" disabled>停止</button>
    <button id="recenter">現在地へ</button>
  </div>

  <div class="row">
    <button id="checkpoint">チェックポイント</button>
    <label><input type="checkbox" id="withMemo" />メモ入力</label>
  </div>

  <div class="row">
    <label>通知距離: <span id="thv">100m</span></label>
    <input id="th" type="range" min="20" max="300" step="10" value="100" />
  </div>

  <div class="row">
    <button id="export">エクスポート</button>
    <span id="stat" class="small"></span>
  </div>

  <div class="row">
    <button id="tts">音声テスト</button>
  </div>
</div>

<button id="fab-recenter">📍</button>

<script src="leaflet.js?v=250839"></script>

<!-- 画像ファイル不要のSVGピン（「？」対策） -->
<script>
(function(){
  const svg=encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><path d="M12 36s10-12.2 10-20A10 10 0 1 0 2 16c0 7.8 10 20 10 20z" fill="#2A7FFF"/><circle cx="12" cy="12" r="4.5" fill="#fff"/></svg>`);
  const dataUrl=`data:image/svg+xml;charset=UTF-8,${svg}`;
  const LocalPin=L.Icon.extend({options:{iconUrl:dataUrl,iconSize:[24,36],iconAnchor:[12,34],popupAnchor:[0,-30],shadowUrl:null}});
  L.Marker.prototype.options.icon=new LocalPin();
})();
</script>

<script src="jszip.min.js?v=250839"></script>
<script src="togeojson.umd.js?v=250839"></script>

<script>
/* ====== Map ====== */
const map=L.map('map').setView([35,135],14);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap contributors'}).addTo(map);
const me=L.circleMarker([35,135],{radius:7,color:'#0ea5e9',fillOpacity:0.7,weight:3}).addTo(map);
/* 軌跡は赤 */
const trackLine=L.polyline([], {color:'#ef4444',weight:5}).addTo(map);
const checkpointLayer=L.layerGroup().addTo(map);

/* ====== State ====== */
let lastLatLng=null, tracking=false, watchId=null, pulseTimer=null;
let notifyMeters=100;
let routeLayer=null;
const routePointLayers=[];
/* 誤発話抑制＆解禁（スタート後すぐの多発防止） */
let announceEnabled=false, startPos=null, trackingStartedAt=0;
const ENABLE_AFTER_METERS=30, ENABLE_AFTER_SECONDS=8;

/* ====== DOM ====== */
const $file=document.getElementById('file');
const $clear=document.getElementById('clear');
const $fname=document.getElementById('fname');
const $track=document.getElementById('track');
const $stop=document.getElementById('stop');
const $rec=document.getElementById('recenter');
const $fab=document.getElementById('fab-recenter');
const $chk=document.getElementById('checkpoint');
const $memo=document.getElementById('withMemo');
const $th=document.getElementById('th');
const $thv=document.getElementById('thv');
const $stat=document.getElementById('stat');
const $recBadge=document.getElementById('recBadge');

/* ====== 音声（iOS強化） ====== */
let voiceReady=false, audioCtx=null;
function getCtx(){ return audioCtx ||= new (window.AudioContext||window.webkitAudioContext)(); }
function ensureAudio(){ try{ getCtx().resume(); }catch(_){} }
function preloadVoices(){ try{ speechSynthesis.getVoices(); }catch(_){} }
window.speechSynthesis?.addEventListener?.('voiceschanged', preloadVoices); preloadVoices();

/* 解錠だけ（ここでは喋らない） */
function unlockTTS(){
  try{
    ensureAudio();
    const ctx=getCtx(), osc=ctx.createOscillator(), gain=ctx.createGain();
    gain.gain.value=0.05; osc.connect(gain).connect(ctx.destination);
    const t=ctx.currentTime; osc.start(t); osc.stop(t+0.08);
    voiceReady=true;
  }catch(e){ console.warn(e); }
}
/* ゆっくり話す */
function speak(text){
  if(!voiceReady){ unlockTTS(); }
  ensureAudio();
  try{
    const u=new SpeechSynthesisUtterance(String(text));
    u.lang='ja-JP'; u.rate=0.85; u.pitch=1; u.volume=1;
    const vs=speechSynthesis.getVoices?.()||[];
    const ja=vs.find(v=>(v.lang||'').toLowerCase().startsWith('ja')); if(ja) u.voice=ja;
    const speakNow=()=>speechSynthesis.speak(u);
    if(speechSynthesis.speaking||speechSynthesis.pending){ speechSynthesis.cancel(); setTimeout(speakNow,50); } else { speakNow(); }
  }catch(e){ console.warn(e); }
}
function isStartName(name){ const n=(name||'').trim(); return /^start$/i.test(n)||/^スタート$/i.test(n); }

/* ====== ルート読込（KML/KMZ） ====== */
function clearRoute(){ if(routeLayer){ map.removeLayer(routeLayer); routeLayer=null; } routePointLayers.length=0; $fname.textContent='（未選択）'; }
$clear.onclick=clearRoute;

$file.addEventListener('change', async (ev)=>{
  const f=ev.target.files?.[0]; if(!f) return;
  $fname.textContent=f.name;
  try{
    let kmlText=null;
    if(/\.kmz$/i.test(f.name)){
      const buf=await f.arrayBuffer();
      const zip=await JSZip.loadAsync(buf);
      const kmlEntry=Object.values(zip.files).find(z=>z.name.toLowerCase().endsWith('.kml'));
      if(!kmlEntry){ alert('KMZ内にKMLがありません'); return; }
      kmlText=await kmlEntry.async('string'); // iOSはstringが安定
    }else{
      kmlText=await f.text();
    }
    const dom=new DOMParser().parseFromString(kmlText,'text/xml');
    const gj=toGeoJSON.kml(dom);

    if(routeLayer) map.removeLayer(routeLayer);
    routeLayer=L.geoJSON(gj,{
      style:{color:'#1d4ed8',weight:4},
      pointToLayer:(feat,latlng)=>{
        const name=feat.properties?.name||feat.properties?.Name||'ポイント';
        const m=L.marker(latlng).bindPopup(name);
        m.feature={properties:{name}}; m._announced=false; m._lastDist=Infinity;
        routePointLayers.push(m);
        return m;
      }
    }).addTo(map);

    try{ map.fitBounds(routeLayer.getBounds(),{padding:[20,20]}); }catch(_){}
    // 追跡中に差し替えた場合でも即チェック
    if (tracking && announceEnabled && lastLatLng) announceInsideAtEnable(L.latLng(lastLatLng));
  }catch(e){ console.warn(e); alert('ファイル読込に失敗：'+(e?.message||e)); }
});

/* ====== 読み上げロジック ====== */
/* 解禁直後：すでに半径内のポイントを読む */
function announceInsideAtEnable(here){
  const list=[...routePointLayers,...Object.values(checkpointLayer._layers||{})];
  for(const layer of list){
    if(!layer?.getLatLng||layer._announced) continue;
    const dist=map.distance(here,layer.getLatLng());
    layer._lastDist=dist;
    if(dist<=notifyMeters){
      const p=layer.feature?.properties||{};
      const name=(p.name||'').trim(), memo=(p.memo||'').trim();
      const justStarted=(Date.now()-trackingStartedAt)<120000;
      if(isStartName(name)&&justStarted) continue;
      const parts=[]; if(name) parts.push(name); if(memo) parts.push(memo);
      if(parts.length) speak(parts.join('。'));
      layer._announced=true;
    }
  }
}
/* 通常：半径内なら必ず一度だけ読む（取り逃し防止） */
function maybeAnnounceNear(here){
  const list=[...routePointLayers,...Object.values(checkpointLayer._layers||{})];
  for(const layer of list){
    if(!layer?.getLatLng||layer._announced) continue;
    const dist=map.distance(here,layer.getLatLng());
    layer._lastDist=dist;
    const p=layer.feature?.properties||{};
    const name=(p.name||'').trim(), memo=(p.memo||'').trim();
    const justStarted=(Date.now()-trackingStartedAt)<120000;
    if(isStartName(name)&&justStarted) continue;
    if(dist<=notifyMeters){
      const parts=[]; if(name) parts.push(name); if(memo) parts.push(memo);
      if(parts.length) speak(parts.join('。'));
      layer._announced=true;
    }
  }
}

/* ====== 操作 ====== */
document.getElementById('tts').onclick=()=>{ unlockTTS(); setTimeout(()=>speak('テストです'),120); };
$th.oninput=()=>{ notifyMeters=+$th.value; $thv.textContent=`${notifyMeters}m`; };

$track.onclick=()=>{
  if(tracking) return;
  unlockTTS();
  setTimeout(()=>speak('評価を開始します'),120);   // スタート時の発話
  tracking=true;
  $track.disabled=true; $stop.disabled=false;
  $recBadge.style.display='flex'; startPulse();
  trackLine.setLatLngs([]);
  checkpointLayer.clearLayers();

  trackingStartedAt=Date.now(); announceEnabled=false; startPos=null;
  routePointLayers.forEach(l=>{ l._announced=false; l._lastDist=Infinity; });
  Object.values(checkpointLayer._layers||{}).forEach(l=>{ l._announced=false; l._lastDist=Infinity; });

  watchId=navigator.geolocation.watchPosition(pos=>{
    lastLatLng=[pos.coords.latitude,pos.coords.longitude];
    me.setLatLng(lastLatLng);
    trackLine.addLatLng(lastLatLng);

    const here=L.latLng(lastLatLng);
    if(!startPos) startPos=here;
    const moved=startPos.distanceTo(here);

    if(!announceEnabled){
      const elapsed=Date.now()-trackingStartedAt;
      if(moved>=ENABLE_AFTER_METERS || elapsed>=ENABLE_AFTER_SECONDS*1000){
        announceEnabled=true;
        announceInsideAtEnable(here);
      }
    }else{
      maybeAnnounceNear(here);
    }
  },err=>{ $stat.textContent=`位置エラー: ${err.message}`; },
  {enableHighAccuracy:true,maximumAge:1000,timeout:10000});
};

$stop.onclick=()=>{
  if(!tracking) return;
  tracking=false;
  if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; }
  $track.disabled=false; $stop.disabled=true;
  $recBadge.style.display='none'; stopPulse();
};

$chk.onclick=()=>{
  if(!lastLatLng){ alert("現在地が取得できていません"); return; }
  let memo=''; if($memo.checked) memo=prompt("メモ入力（任意）","");
  const m=L.marker(lastLatLng).addTo(checkpointLayer);
  m.feature={properties:{name:'チェックポイント', memo:memo||''}};
  m.bindPopup(memo?`<b>CP</b><br>${memo}`:"<b>CP</b>");
  m._announced=false; m._lastDist=Infinity;
};

$rec.onclick=()=>{ if(lastLatLng) map.setView(lastLatLng,16); };
$fab.onclick=()=>$rec.click();

/* ====== 演出 ====== */
function startPulse(){ let up=true; pulseTimer=setInterval(()=>{ let r=me.options.radius; r=up?Math.min(11,r+0.5):Math.max(7,r-0.5); me.setStyle({radius:r}); if(r>=11)up=false; if(r<=7)up=true; },80); }
function stopPulse(){ clearInterval(pulseTimer); pulseTimer=null; me.setStyle({radius:7}); }

/* 初回位置 */
if(navigator.geolocation){
  navigator.geolocation.getCurrentPosition(pos=>{
    lastLatLng=[pos.coords.latitude,pos.coords.longitude];
    me.setLatLng(lastLatLng); map.setView(lastLatLng,16);
  },()=>{});
}

/* ====== エクスポート（GeoJSON） ====== */
document.getElementById('export').onclick=()=>{
  const gj={type:'FeatureCollection',features:[
    {type:'Feature',properties:{kind:'track'},geometry:{type:'LineString',coordinates:trackLine.getLatLngs().map(ll=>[ll.lng,ll.lat])}}
  ]};
  Object.values(checkpointLayer._layers||{}).forEach(m=>{
    const p=m.feature?.properties||{};
    gj.features.push({type:'Feature',properties:{kind:'checkpoint',...p},geometry:{type:'Point',coordinates:[m.getLatLng().lng,m.getLatLng().lat]}});
  });
  const blob=new Blob([JSON.stringify(gj,null,2)],{type:'application/geo+json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  a.download=`route_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.geojson`;
  a.click(); URL.revokeObjectURL(a.href);
};
</script>
</body>
</html>
