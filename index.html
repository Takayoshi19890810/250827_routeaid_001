<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Route Aid â€“ è¿½è·¡ï¼†è»Œè·¡ä¿å­˜</title>
  <link rel="stylesheet" href="./leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    $1
    .status-pill { display:inline-flex; align-items:center; gap:6px; padding:.35rem .6rem; border-radius:999px; background:#f3f4f6;}
    .status-pill .dot { width:8px; height:8px; border-radius:999px; background:#9ca3af; }
    .status-running { background:#fee2e2; color:#b91c1c; }
    .status-running .dot { background:#ef4444; animation: pulse 1s ease-in-out infinite alternate; }
    .status-paused { background:#fffbeb; color:#92400e; }
    .status-paused .dot { background:#f59e0b; }
    .status-stopped { background:#e5e7eb; color:#374151; }
    .status-idle { background:#f3f4f6; color:#374151; }
    @keyframes pulse { from { opacity:.6; transform: scale(1); } to { opacity:1; transform: scale(1.25);} }
    #map { width: 100%; height: 100%; }
    .stat { font-variant-numeric: tabular-nums; }
    .toast { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); background: rgba(0,0,0,.85); color:#fff; padding: 10px 14px; border-radius: 10px; font-size: 13px; z-index: 9999; }
  </style>
  <link rel="manifest" href="./manifest.webmanifest" />
  <script>
    // PWA: SWç™»éŒ²ï¼ˆæ—¢å­˜ã® sw.js ã‚’ãã®ã¾ã¾åˆ©ç”¨ï¼‰
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.warn);
      });
    }
  </script>
</head>
<body>
<div id="app">
  <header>
    <span class="title">Route Aid</span>
    <span class="sep"></span>

    <button id="btnStart" class="primary">â–¶ è¿½è·¡é–‹å§‹</button>
    <button id="btnPause" disabled>â¸ ä¸€æ™‚åœæ­¢</button>
    <button id="btnResume" disabled>â–¶ å†é–‹</button>
    <button id="btnStop" class="destructive" disabled>â–  åœæ­¢</button>

    <span class="sep"></span>

    <span class="pill stat">è·é›¢: <span id="dist">0.00</span> km</span>
    $1

    $1

    <span class=\"pill stat\">æ™‚é–“: <span id=\"elapsed\">00:00:00</span></span>
      <span id="runStatusText">å¾…æ©Ÿä¸­</span>
    </span>

    <span class="sep"></span>

    <label>ãƒ•ã‚¡ã‚¤ãƒ«å: <input id="fname" placeholder="Track_YYYYMMDD_HHMMSS" style="width: 190px"/></label>
    <button id="btnSaveGPX" disabled>ğŸ’¾ GPXä¿å­˜</button>
    <button id="btnSaveGeoJSON" disabled>ğŸ’¾ GeoJSONä¿å­˜</button>

    <button id="btnPickDir" title="å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã®ã¿ï¼ˆChrome/Edgeç­‰ï¼‰">ğŸ“ ä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€æŒ‡å®š</button>
    <span id="dirLabel" class="pill" title="File System Access API">æœªæŒ‡å®š</span>
  </header>
  <div id="map"></div>
</div>

<script src="./leaflet.js"></script>
<script>
  // ====== è¿½è·¡ãƒ»æç”»ã®ã‚³ã‚¢çŠ¶æ…‹ ======
  let map, currentMarker, trackLine;
  let startTime = null;
  let elapsedTimer = null;
  let watchId = null;
  let points = []; // {lat, lng, t}
  let distMeters = 0;
  let following = true; // é–‹å§‹æ™‚ã¯è¿½å¾“

  // ä¿å­˜å…ˆï¼ˆFile System Access APIï¼‰
  let dirHandle = null; // ãƒ•ã‚©ãƒ«ãƒ€ãƒãƒ³ãƒ‰ãƒ«ï¼ˆæ¨©é™ä»˜ä¸æ¸ˆã¿ãªã‚‰ã“ã“ã«ä¿æŒï¼‰

  // ====== åˆæœŸåŒ– ======
  function init() {
    map = L.map('map');
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // åˆæœŸä½ç½®ã¯æ—¥æœ¬ä¸­å¿ƒã‚ãŸã‚Š
    map.setView([35.681236, 139.767125], 13);

    trackLine = L.polyline([], { color: 'red', weight: 4, opacity: 0.9 }).addTo(map);

    // UIã‚¤ãƒ™ãƒ³ãƒˆ
    document.getElementById('btnStart').addEventListener('click', startTracking);
    document.getElementById('btnPause').addEventListener('click', pauseTracking);
    document.getElementById('btnResume').addEventListener('click', resumeTracking);
    document.getElementById('btnStop').addEventListener('click', stopTracking);
    document.getElementById('btnSaveGPX').addEventListener('click', () => saveTrack('gpx'));
    document.getElementById('btnSaveGeoJSON').addEventListener('click', () => saveTrack('geojson'));
    document.getElementById('btnPickDir').addEventListener('click', pickDirectory);

    // æ—¢å®šãƒ•ã‚¡ã‚¤ãƒ«å
    document.getElementById('fname').value = defaultFileName();
  }

  function toast(msg, ms = 1600) {
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(() => t.remove(), ms);
  }

  function defaultFileName() {
    const d = new Date();
    const pad = n => String(n).padStart(2, '0');
    return `Track_${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }

  // ====== è¿½è·¡ãƒ­ã‚¸ãƒƒã‚¯ ======
  function startTracking() {
    if (!('geolocation' in navigator)) { toast('ã“ã®ç«¯æœ«ã¯ä½ç½®æƒ…å ±ã«æœªå¯¾å¿œã§ã™'); return; }

    points = []; distMeters = 0;
    updateStats();
    trackLine.setLatLngs([]);

    if (currentMarker) { currentMarker.remove(); }

    const options = {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 20000
    };

    watchId = navigator.geolocation.watchPosition(onPos, onErr, options);

    startTime = new Date();
    if (elapsedTimer) clearInterval(elapsedTimer);
    elapsedTimer = setInterval(updateElapsed, 1000);

    setButtons({ running: true, paused: false });
    toast('è©•ä¾¡ã‚’é–‹å§‹ã—ã¾ã™ï¼ˆè¿½è·¡é–‹å§‹ï¼‰');
    setRunStatus('running');
    try { if (navigator.vibrate) navigator.vibrate(50); } catch(_){}
    setRunStatus('running');
    try { if (navigator.vibrate) navigator.vibrate(50); } catch(_){}
  }

  function onPos(pos) {
    const { latitude: lat, longitude: lng } = pos.coords;
    const t = new Date();

    // æœ«å°¾ã¨è·é›¢è¨ˆç®—
    const last = points.length ? points[points.length - 1] : null;
    const p = { lat, lng, t: t.toISOString() };
    points.push(p);

    if (last) distMeters += haversine(last.lat, last.lng, lat, lng);

    // æç”»æ›´æ–°
    trackLine.addLatLng([lat, lng]);

    if (!currentMarker) {
      currentMarker = L.marker([lat, lng]).addTo(map);
    } else {
      currentMarker.setLatLng([lat, lng]);
    }

    if (following) {
      map.setView([lat, lng], Math.max(map.getZoom(), 16), { animate: false });
    }

    updateStats();
  }

  function onErr(err) {
    console.warn('Geolocation error:', err);
    toast('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  function pauseTracking() {
    if (watchId != null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
      if (elapsedTimer) { clearInterval(elapsedTimer); elapsedTimer=null; }
      setButtons({ running: false, paused: true });
      toast('ä¸€æ™‚åœæ­¢');
      setRunStatus('paused');
    }
  }

  function resumeTracking() {
    if (watchId == null) {
      const options = { enableHighAccuracy: true, maximumAge: 1000, timeout: 20000 };
      watchId = navigator.geolocation.watchPosition(onPos, onErr, options);
      if (!startTime) startTime=new Date();
      if (elapsedTimer) clearInterval(elapsedTimer);
      elapsedTimer=setInterval(updateElapsed,1000);
      setButtons({ running: true, paused: false, resume: true });
      toast('è¿½è·¡ã‚’å†é–‹');
      setRunStatus('running');
    }
  }

  function stopTracking() {
    if (watchId != null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
    if (elapsedTimer) { clearInterval(elapsedTimer); elapsedTimer=null; }
    setButtons({ running: false, paused: false, stopped: true });
    toast('åœæ­¢ã—ã¾ã—ãŸã€‚ä¿å­˜ã§ãã¾ã™');
    setRunStatus('stopped');
    try { if (navigator.vibrate) navigator.vibrate([30,40,30]); } catch(_){}
  }

  function setButtons(state) {
    const start = document.getElementById('btnStart');
    const pause = document.getElementById('btnPause');
    const resume = document.getElementById('btnResume');
    const stopB = document.getElementById('btnStop');
    const saveG = document.getElementById('btnSaveGPX');
    const saveJ = document.getElementById('btnSaveGeoJSON');

    if (state.running) {
      start.disabled = true; pause.disabled = false; resume.disabled = true; stopB.disabled = false; saveG.disabled = true; saveJ.disabled = true;
    } else if (state.paused) {
      start.disabled = true; pause.disabled = true; resume.disabled = false; stopB.disabled = false; saveG.disabled = true; saveJ.disabled = true;
    } else if (state.stopped) {
      start.disabled = false; pause.disabled = true; resume.disabled = true; stopB.disabled = true; saveG.disabled = false; saveJ.disabled = false;
    } else {
      // åˆæœŸ
      start.disabled = false; pause.disabled = true; resume.disabled = true; stopB.disabled = true; saveG.disabled = true; saveJ.disabled = true;
    }
  }

  function updateStats() {
    document.getElementById('pts').textContent = String(points.length);
    document.getElementById('dist').textContent = (distMeters / 1000).toFixed(2);
  }

  // ====== ä¿å­˜å‡¦ç† ======
  async function saveTrack(fmt) {
    if (points.length < 2) { toast('ä¿å­˜ã§ãã‚‹è»Œè·¡ãŒã‚ã‚Šã¾ã›ã‚“'); return; }

    const nameRaw = (document.getElementById('fname').value || defaultFileName()).trim();
    const safe = nameRaw.replace(/[^\w\-_.]/g, '_');
    const filename = fmt === 'gpx' ? `${safe}.gpx` : `${safe}.geojson`;

    try {
      let dataStr, mime;
      if (fmt === 'gpx') { dataStr = buildGPX(points); mime = 'application/gpx+xml'; }
      else { dataStr = JSON.stringify(buildGeoJSON(points), null, 2); mime = 'application/geo+json'; }

      if (dirHandle && (await verifyPermission(dirHandle, true))) {
        const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(new Blob([dataStr], { type: mime }));
        await writable.close();
        toast(`ä¿å­˜ã—ã¾ã—ãŸ: ${filename}`);
      } else {
        // Fallback: é€šå¸¸ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([dataStr], { type: mime }));
        a.download = filename;
        document.body.appendChild(a); a.click(); a.remove();
        toast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã—ãŸ');
      }
    } catch (e) {
      console.error(e);
      toast('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }

  function buildGeoJSON(pts) {
    return {
      type: 'FeatureCollection',
      features: [{
        type: 'Feature',
        properties: {
          name: 'Recorded Track',
          points: pts.length,
          distance_m: Math.round(distMeters)
        },
        geometry: {
          type: 'LineString',
          coordinates: pts.map(p => [p.lng, p.lat])
        }
      }]
    };
  }

  function buildGPX(pts) {
    const esc = s => s.replace(/[<&>]/g, c => ({'<':'&lt;','&':'&amp;','>':'&gt;'}[c]));
    const trkpts = pts.map(p => `      <trkpt lat="${p.lat}" lon="${p.lng}">\n        <time>${p.t}</time>\n      </trkpt>`).join('\n');
    return `<?xml version="1.0" encoding="UTF-8"?>\n`+
`<gpx version="1.1" creator="Route Aid" xmlns="http://www.topografix.com/GPX/1/1">\n`+
`  <trk>\n`+
`    <name>${esc(document.getElementById('fname').value || 'Recorded Track')}</name>\n`+
`    <trkseg>\n`+
`${trkpts}\n`+
`    </trkseg>\n`+
`  </trk>\n`+
`</gpx>`;
  }

  async function pickDirectory() {
    if (!('showDirectoryPicker' in window)) { toast('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ãƒ•ã‚©ãƒ«ãƒ€æŒ‡å®šã«æœªå¯¾å¿œã§ã™ã€‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¿å­˜ã‚’ã”åˆ©ç”¨ãã ã•ã„'); return; }
    try {
      dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      if (await verifyPermission(dirHandle, true)) {
        document.getElementById('dirLabel').textContent = 'æŒ‡å®šæ¸ˆã¿';
        toast('ä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€ã‚’æŒ‡å®šã—ã¾ã—ãŸ');
      }
    } catch (e) {
      if (e && e.name !== 'AbortError') console.warn(e);
    }
  }

  async function verifyPermission(fileHandle, withWrite) {
    const opts = {};
    if (withWrite) opts.mode = 'readwrite';
    if ((await fileHandle.queryPermission(opts)) === 'granted') return true;
    if ((await fileHandle.requestPermission(opts)) === 'granted') return true;
    return false;
  }

  // ====== è·é›¢ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰è¨ˆç®—ï¼ˆHaversineï¼‰ ======
  function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000; // m
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  function setRunStatus(mode){
    const pill = document.getElementById('runStatus');
    const text = document.getElementById('runStatusText');
    if (!pill || !text) return;
    pill.classList.remove('status-idle','status-running','status-paused','status-stopped');
    if (mode==='running'){ pill.classList.add('status-running'); text.textContent='è¿½è·¡ä¸­'; document.title='â— è¿½è·¡ä¸­ â€“ Route Aid'; }
    else if (mode==='paused'){ pill.classList.add('status-paused'); text.textContent='ä¸€æ™‚åœæ­¢'; document.title='â¸ ä¸€æ™‚åœæ­¢ â€“ Route Aid'; }
    else if (mode==='stopped'){ pill.classList.add('status-stopped'); text.textContent='åœæ­¢'; document.title='Route Aid â€“ è¿½è·¡ï¼†è»Œè·¡ä¿å­˜'; }
    else { pill.classList.add('status-idle'); text.textContent='å¾…æ©Ÿä¸­'; document.title='Route Aid â€“ è¿½è·¡ï¼†è»Œè·¡ä¿å­˜'; }
  }

  function updateElapsed(){
    if (!startTime) return;
    const now=new Date();
    const sec=Math.floor((now-startTime)/1000);
    const h=Math.floor(sec/3600).toString().padStart(2,'0');
    const m=Math.floor((sec%3600)/60).toString().padStart(2,'0');
    const s=(sec%60).toString().padStart(2,'0');
    document.getElementById('elapsed').textContent=`${h}:${m}:${s}`;
  }

  // èµ·å‹•
  init();
  setRunStatus('idle');
  setRunStatus('idle');
</script>
</body>
</html>
