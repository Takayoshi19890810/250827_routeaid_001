<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>My Maps KMZ 読み上げ（個別スタイルのみ）＋ルート表示</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  html, body, #map { height: 100%; margin: 0; }
  .toolbar{position:absolute;z-index:1000;left:8px;top:8px;background:#fff;border-radius:12px;box-shadow:0 4px 14px rgba(0,0,0,.12);padding:10px;font:14px/1.4 system-ui;}
  .toolbar label{display:block;margin-bottom:6px}
</style>
</head>
<body>
<div class="toolbar">
  <label>KMZを選択： <input type="file" id="kmzInput" accept=".kmz"></label>
  <label>読み上げ半径（m）： <input type="number" id="radius" value="120" min="10" step="10" style="width:6em"></label>
  <button id="startBtn">追跡開始</button>
  <button id="stopBtn" disabled>追跡終了</button>
  <div id="status">GPS未取得</div>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@5.8.1/dist/togeojson.umd.js"></script>

<script>
// ====== 地図セットアップ ======
const map = L.map('map').setView([35.681, 139.767], 12);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution:'© OSM'}).addTo(map);

let routeLayer = L.geoJSON(null, { style:{color:'#0a84ff', weight:4, opacity:0.9} }).addTo(map);
let markerLayer = L.geoJSON(null, {
  pointToLayer: (feat, latlng) => L.circleMarker(latlng, {radius:7, color:'#e11d48', fillColor:'#fb7185', fillOpacity:0.9, weight:2})
}).addTo(map);

let watchId = null;
let alreadySpokenIds = new Set();
let currentPosMarker = null;

// ====== KMZ読込：JSZipで解凍→doc.kml→toGeoJSON ======
async function loadKmz(file) {
  const zip = await JSZip.loadAsync(file);
  // My MapsのKMZは通常 doc.kml を含む
  const kmlFile = zip.file(/doc\.kml$/i)[0] || zip.file(/\.kml$/i)[0];
  if (!kmlFile) { alert("KMZ内にKMLが見つかりませんでした"); return; }
  const kmlText = await kmlFile.async('text');

  // KML→GeoJSON
  const kmlDom = new DOMParser().parseFromString(kmlText, 'text/xml');
  const gj = toGeoJSON.kml(kmlDom);

  // フォルダ（レイヤ）名で振り分け：My Mapsはレイヤ=Folderとして出力
  // 想定：レイヤ名に「ルート」など明示。なければジオメトリタイプで判定。
  const routeFC = { type:'FeatureCollection', features:[] };
  const pointFC = { type:'FeatureCollection', features:[] };

  for (const f of gj.features) {
    const name = (f.properties && (f.properties.name || f.properties._folder)) || '';
    const geom = f.geometry && f.geometry.type;
    const inRouteFolder =
      /route|ルート|道順|経路/i.test(name) ||
      /route|ルート|道順|経路/i.test(f.properties?._folder || '');

    if (geom === 'LineString' || geom === 'MultiLineString' || inRouteFolder) {
      // ルート → 線だけ表示（Pointは捨てる）
      if (geom === 'LineString' || geom === 'MultiLineString') routeFC.features.push(f);
      // ルート用のPointは何もしない（非表示＆非読み上げ）
    } else if (geom === 'Point') {
      // 個別スタイルのマーカー（=ポイント）
      // ただし、レイヤ名が「ルート」系なら除外
      const folder = (f.properties && f.properties._folder) || '';
      if (!/route|ルート|道順|経路/i.test(folder)) pointFC.features.push(f);
    }
  }

  routeLayer.clearLayers().addData(routeFC);
  markerLayer.clearLayers().addData(pointFC);

  // フィット
  const group = L.featureGroup([routeLayer, markerLayer]);
  if (group.getLayers().length) map.fitBounds(group.getBounds(), {padding:[40,40]});
}

// ====== 音声読み上げ ======
function speak(text) {
  if (!text) return;
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'ja-JP';
  u.rate = 0.95; // 少しゆっくり
  speechSynthesis.cancel(); // 直前の発話をキャンセル（重複防止）
  speechSynthesis.speak(u);
}

// ====== 追跡（半径内で読み上げ） ======
function startTracking() {
  if (!navigator.geolocation) { alert('この端末は位置情報に対応していません'); return; }
  const radiusM = Number(document.getElementById('radius').value) || 120;

  alreadySpokenIds.clear();
  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;
  speak('評価を開始します');

  watchId = navigator.geolocation.watchPosition(pos => {
    const { latitude, longitude, accuracy } = pos.coords;
    document.getElementById('status').textContent =
      `GPS取得: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}（±${Math.round(accuracy)}m）`;

    const latlng = [latitude, longitude];
    if (!currentPosMarker) {
      currentPosMarker = L.circleMarker(latlng, {radius:6, color:'#111', fillColor:'#333', fillOpacity:0.9}).addTo(map);
    } else {
      currentPosMarker.setLatLng(latlng);
    }

    // 近接判定：markerLayer内の各ポイントへ距離計算
    markerLayer.eachLayer(layer => {
      const f = layer.feature || {};
      const id = f.id || (f.properties && (f.properties.name + '@' + JSON.stringify(f.geometry.coordinates))) || layer._leaflet_id;
      if (alreadySpokenIds.has(id)) return;

      const pt = layer.getLatLng();
      const d = map.distance(latlng, [pt.lat, pt.lng]); // m
      if (d <= radiusM) {
        // 読み上げ内容：名前＋（あれば）説明/メモ
        const name = f.properties && f.properties.name ? f.properties.name : 'ポイント';
        const desc = (f.properties && (f.properties.description || f.properties.snippet)) || '';
        const text = desc ? `${name}、${desc}` : name;
        speak(text);
        alreadySpokenIds.add(id);
      }
    });
  }, err => {
    document.getElementById('status').textContent = 'GPSエラー：' + err.message;
    // しばらくFixが入らないアラート
    speak('GPS信号が弱いです');
  }, { enableHighAccuracy:true, maximumAge:5000, timeout:15000 });
}

function stopTracking() {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
  speak('評価を終了します');
  document.getElementById('status').textContent = '追跡停止';
}

// ====== UIイベント ======
document.getElementById('kmzInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  await loadKmz(file);
});

document.getElementById('startBtn').addEventListener('click', startTracking);
document.getElementById('stopBtn').addEventListener('click', stopTracking);

// D&Dでも読み込み
window.addEventListener('dragover', e => { e.preventDefault(); });
window.addEventListener('drop', async e => {
  e.preventDefault();
  const file = [...e.dataTransfer.files].find(f => /\.kmz$/i.test(f.name));
  if (file) await loadKmz(file);
});
</script>
</body>
</html>
