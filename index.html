<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Route Aid – 追跡＆軌跡保存</title>
  <link rel="stylesheet" href="./leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { padding: .5rem .75rem; display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; box-shadow: 0 1px 0 rgba(0,0,0,.08); }
    header .title { font-weight: 700; margin-right: .5rem; }
    header .sep { width: 1px; height: 24px; background: #e5e7eb; margin: 0 .25rem; }
    header button, header input, header select, header label { font-size: 14px; }
    header button { padding: .5rem .7rem; border-radius: 10px; border: 1px solid #e5e7eb; background: #fff; cursor: pointer; }
    header button.primary { background: #111827; color: white; border-color: #111827; }
    header button.destructive { background: #dc2626; color: white; border-color: #dc2626; }
    header button:disabled { opacity: .5; cursor: not-allowed; }
    header .pill { padding: .35rem .6rem; border-radius: 999px; background: #f3f4f6; }
    #map { width: 100%; height: 100%; }
    .stat { font-variant-numeric: tabular-nums; }
    .toast { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); background: rgba(0,0,0,.85); color:#fff; padding: 10px 14px; border-radius: 10px; font-size: 13px; z-index: 9999; }
  </style>
  <link rel="manifest" href="./manifest.webmanifest" />
  <script>
    // PWA: SW登録（既存の sw.js をそのまま利用）
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.warn);
      });
    }
  </script>
</head>
<body>
<div id="app">
  <header>
    <span class="title">Route Aid</span>
    <span class="sep"></span>

    <button id="btnStart" class="primary">▶ 追跡開始</button>
    <button id="btnPause" disabled>⏸ 一時停止</button>
    <button id="btnResume" disabled>▶ 再開</button>
    <button id="btnStop" class="destructive" disabled>■ 停止</button>

    <span class="sep"></span>

    <span class="pill stat">距離: <span id="dist">0.00</span> km</span>
    <span class="pill stat">ポイント: <span id="pts">0</span></span>

    <span class="sep"></span>

    <label>ファイル名: <input id="fname" placeholder="Track_YYYYMMDD_HHMMSS" style="width: 190px"/></label>
    <button id="btnSaveGPX" disabled>💾 GPX保存</button>
    <button id="btnSaveGeoJSON" disabled>💾 GeoJSON保存</button>

    <button id="btnPickDir" title="対応ブラウザのみ（Chrome/Edge等）">📁 保存先フォルダ指定</button>
    <span id="dirLabel" class="pill" title="File System Access API">未指定</span>
  </header>
  <div id="map"></div>
</div>

<script src="./leaflet.js"></script>
<script>
  // ====== 追跡・描画のコア状態 ======
  let map, currentMarker, trackLine;
  let watchId = null;
  let points = []; // {lat, lng, t}
  let distMeters = 0;
  let following = true; // 開始時は追従

  // 保存先（File System Access API）
  let dirHandle = null; // フォルダハンドル（権限付与済みならここに保持）

  // ====== 初期化 ======
  function init() {
    map = L.map('map');
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // 初期位置は日本中心あたり
    map.setView([35.681236, 139.767125], 13);

    trackLine = L.polyline([], { color: 'red', weight: 4, opacity: 0.9 }).addTo(map);

    // UIイベント
    document.getElementById('btnStart').addEventListener('click', startTracking);
    document.getElementById('btnPause').addEventListener('click', pauseTracking);
    document.getElementById('btnResume').addEventListener('click', resumeTracking);
    document.getElementById('btnStop').addEventListener('click', stopTracking);
    document.getElementById('btnSaveGPX').addEventListener('click', () => saveTrack('gpx'));
    document.getElementById('btnSaveGeoJSON').addEventListener('click', () => saveTrack('geojson'));
    document.getElementById('btnPickDir').addEventListener('click', pickDirectory);

    // 既定ファイル名
    document.getElementById('fname').value = defaultFileName();
  }

  function toast(msg, ms = 1600) {
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(() => t.remove(), ms);
  }

  function defaultFileName() {
    const d = new Date();
    const pad = n => String(n).padStart(2, '0');
    return `Track_${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }

  // ====== 追跡ロジック ======
  function startTracking() {
    if (!('geolocation' in navigator)) { toast('この端末は位置情報に未対応です'); return; }

    points = []; distMeters = 0;
    updateStats();
    trackLine.setLatLngs([]);

    if (currentMarker) { currentMarker.remove(); }

    const options = {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 20000
    };

    watchId = navigator.geolocation.watchPosition(onPos, onErr, options);

    setButtons({ running: true, paused: false });
    toast('評価を開始します（追跡開始）');
  }

  function onPos(pos) {
    const { latitude: lat, longitude: lng } = pos.coords;
    const t = new Date();

    // 末尾と距離計算
    const last = points.length ? points[points.length - 1] : null;
    const p = { lat, lng, t: t.toISOString() };
    points.push(p);

    if (last) distMeters += haversine(last.lat, last.lng, lat, lng);

    // 描画更新
    trackLine.addLatLng([lat, lng]);

    if (!currentMarker) {
      currentMarker = L.marker([lat, lng]).addTo(map);
    } else {
      currentMarker.setLatLng([lat, lng]);
    }

    if (following) {
      map.setView([lat, lng], Math.max(map.getZoom(), 16), { animate: false });
    }

    updateStats();
  }

  function onErr(err) {
    console.warn('Geolocation error:', err);
    toast('位置情報の取得に失敗しました');
  }

  function pauseTracking() {
    if (watchId != null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
      setButtons({ running: false, paused: true });
      toast('一時停止');
    }
  }

  function resumeTracking() {
    if (watchId == null) {
      startTracking(); // 位置監視を再開（配列は継続利用）
      setButtons({ running: true, paused: false, resume: true });
      toast('追跡を再開');
    }
  }

  function stopTracking() {
    if (watchId != null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
    setButtons({ running: false, paused: false, stopped: true });
    toast('停止しました。保存できます');
  }

  function setButtons(state) {
    const start = document.getElementById('btnStart');
    const pause = document.getElementById('btnPause');
    const resume = document.getElementById('btnResume');
    const stopB = document.getElementById('btnStop');
    const saveG = document.getElementById('btnSaveGPX');
    const saveJ = document.getElementById('btnSaveGeoJSON');

    if (state.running) {
      start.disabled = true; pause.disabled = false; resume.disabled = true; stopB.disabled = false; saveG.disabled = true; saveJ.disabled = true;
    } else if (state.paused) {
      start.disabled = true; pause.disabled = true; resume.disabled = false; stopB.disabled = false; saveG.disabled = true; saveJ.disabled = true;
    } else if (state.stopped) {
      start.disabled = false; pause.disabled = true; resume.disabled = true; stopB.disabled = true; saveG.disabled = false; saveJ.disabled = false;
    } else {
      // 初期
      start.disabled = false; pause.disabled = true; resume.disabled = true; stopB.disabled = true; saveG.disabled = true; saveJ.disabled = true;
    }
  }

  function updateStats() {
    document.getElementById('pts').textContent = String(points.length);
    document.getElementById('dist').textContent = (distMeters / 1000).toFixed(2);
  }

  // ====== 保存処理 ======
  async function saveTrack(fmt) {
    if (points.length < 2) { toast('保存できる軌跡がありません'); return; }

    const nameRaw = (document.getElementById('fname').value || defaultFileName()).trim();
    const safe = nameRaw.replace(/[^\w\-_.]/g, '_');
    const filename = fmt === 'gpx' ? `${safe}.gpx` : `${safe}.geojson`;

    try {
      let dataStr, mime;
      if (fmt === 'gpx') { dataStr = buildGPX(points); mime = 'application/gpx+xml'; }
      else { dataStr = JSON.stringify(buildGeoJSON(points), null, 2); mime = 'application/geo+json'; }

      if (dirHandle && (await verifyPermission(dirHandle, true))) {
        const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(new Blob([dataStr], { type: mime }));
        await writable.close();
        toast(`保存しました: ${filename}`);
      } else {
        // Fallback: 通常のダウンロード
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([dataStr], { type: mime }));
        a.download = filename;
        document.body.appendChild(a); a.click(); a.remove();
        toast('ダウンロードを開始しました');
      }
    } catch (e) {
      console.error(e);
      toast('保存に失敗しました');
    }
  }

  function buildGeoJSON(pts) {
    return {
      type: 'FeatureCollection',
      features: [{
        type: 'Feature',
        properties: {
          name: 'Recorded Track',
          points: pts.length,
          distance_m: Math.round(distMeters)
        },
        geometry: {
          type: 'LineString',
          coordinates: pts.map(p => [p.lng, p.lat])
        }
      }]
    };
  }

  function buildGPX(pts) {
    const esc = s => s.replace(/[<&>]/g, c => ({'<':'&lt;','&':'&amp;','>':'&gt;'}[c]));
    const trkpts = pts.map(p => `      <trkpt lat="${p.lat}" lon="${p.lng}">\n        <time>${p.t}</time>\n      </trkpt>`).join('\n');
    return `<?xml version="1.0" encoding="UTF-8"?>\n`+
`<gpx version="1.1" creator="Route Aid" xmlns="http://www.topografix.com/GPX/1/1">\n`+
`  <trk>\n`+
`    <name>${esc(document.getElementById('fname').value || 'Recorded Track')}</name>\n`+
`    <trkseg>\n`+
`${trkpts}\n`+
`    </trkseg>\n`+
`  </trk>\n`+
`</gpx>`;
  }

  async function pickDirectory() {
    if (!('showDirectoryPicker' in window)) { toast('このブラウザはフォルダ指定に未対応です。ダウンロード保存をご利用ください'); return; }
    try {
      dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      if (await verifyPermission(dirHandle, true)) {
        document.getElementById('dirLabel').textContent = '指定済み';
        toast('保存先フォルダを指定しました');
      }
    } catch (e) {
      if (e && e.name !== 'AbortError') console.warn(e);
    }
  }

  async function verifyPermission(fileHandle, withWrite) {
    const opts = {};
    if (withWrite) opts.mode = 'readwrite';
    if ((await fileHandle.queryPermission(opts)) === 'granted') return true;
    if ((await fileHandle.requestPermission(opts)) === 'granted') return true;
    return false;
  }

  // ====== 距離（メートル）計算（Haversine） ======
  function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000; // m
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  // 起動
  init();
</script>
</body>
</html>
